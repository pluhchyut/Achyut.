<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Reflective Void Portfolio</title>
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }
    
    body {
      font-family: 'Courier New', monospace;
      background: #000;
      overflow: hidden;
    }
    
    #canvas {
      display: block;
      width: 100vw;
      height: 100vh;
    }
    
    .label {
      position: absolute;
      color: white;
      font-size: 24px;
      font-weight: 100;
      letter-spacing: 4px;
      pointer-events: none;
      opacity: 0;
      transition: opacity 0.3s;
      text-shadow: 0 0 20px rgba(255,255,255,0.5);
      transform: translate(-50%, -50%);
    }
    
    .label.visible {
      opacity: 1;
    }
    
    .label-desc {
      font-size: 12px;
      opacity: 0.6;
      letter-spacing: 2px;
      margin-top: 8px;
    }
    
    .footer {
      position: absolute;
      bottom: 20px;
      left: 50%;
      transform: translateX(-50%);
      color: white;
      font-size: 10px;
      letter-spacing: 3px;
      opacity: 0.3;
    }
    
    .project-overlay {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      color: white;
      opacity: 0;
      pointer-events: none;
      transition: opacity 1s;
      z-index: 10;
      background: rgba(0, 0, 0, 0.7);
    }
    
    .project-overlay.visible {
      opacity: 1;
      pointer-events: all;
    }
    
    .fade-overlay {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: black;
      opacity: 0;
      pointer-events: none;
      transition: opacity 0.8s;
      z-index: 5;
    }
    
    .fade-overlay.active {
      opacity: 1;
    }
    
    .project-title {
      font-size: 48px;
      letter-spacing: 8px;
      margin-bottom: 16px;
      text-shadow: 0 0 30px currentColor;
    }
    
    .project-description {
      font-size: 16px;
      letter-spacing: 3px;
      opacity: 0.7;
      margin-bottom: 32px;
    }
    
    .back-button {
      padding: 12px 32px;
      border: 2px solid white;
      background: transparent;
      color: white;
      font-family: 'Courier New', monospace;
      font-size: 14px;
      letter-spacing: 3px;
      cursor: pointer;
      transition: all 0.3s;
      margin-top: 20px;
    }
    
    .back-button:hover {
      background: white;
      color: black;
      box-shadow: 0 0 20px white;
    }
  </style>
</head>
<body>
  <canvas id="canvas"></canvas>
  <div id="label" class="label">
    <div id="label-name"></div>
    <div class="label-desc" id="label-desc"></div>
  </div>
  
  <div id="project-overlay" class="project-overlay">
    <div class="project-title" id="project-title"></div>
    <div class="project-description" id="project-description"></div>
    <button class="back-button" id="back-button">← RETURN TO VOID</button>
  </div>
  
  <div id="fade-overlay" class="fade-overlay"></div>
  
  <div class="footer">ACHYUT V KUMAR • PORTFOLIO 2025</div>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
  
  <script>
    // Scene setup
    const scene = new THREE.Scene();
    scene.fog = new THREE.FogExp2(0x000000, 0.015);
    
    const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
    camera.position.z = 20;
    
    const renderer = new THREE.WebGLRenderer({ 
      canvas: document.getElementById('canvas'),
      antialias: true,
      alpha: true 
    });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
    renderer.toneMapping = THREE.ACESFilmicToneMapping;
    renderer.toneMappingExposure = 1.2;
    
    // Projects data
    const projects = [
      { name: 'NEURAL AI', desc: 'Machine Learning Pipeline', color: 0x00ffff },
      { name: 'WEB DASHBOARD', desc: 'Real-time Analytics', color: 0xff00ff },
      { name: 'GAME ENGINE', desc: 'Voxel World Builder', color: 0xffff00 },
      { name: 'DATA VIZ', desc: 'Interactive Charts', color: 0x00ff00 },
      { name: 'BLOCKCHAIN', desc: 'Smart Contract System', color: 0xff6600 }
    ];
    
    // State management
    let currentMode = 'void'; // 'void' or 'project'
    let currentProjectId = null;
    let projectObjects = [];
    
    // Lighting
    const ambientLight = new THREE.AmbientLight(0xffffff, 0.3);
    scene.add(ambientLight);
    
    const pointLight = new THREE.PointLight(0xffffff, 2, 100);
    pointLight.position.set(10, 10, 10);
    scene.add(pointLight);
    
    const rimLight = new THREE.PointLight(0x4444ff, 1.5, 50);
    rimLight.position.set(-5, 5, -5);
    scene.add(rimLight);
    
    const backLight = new THREE.PointLight(0xff4444, 1, 40);
    backLight.position.set(0, -10, -10);
    scene.add(backLight);
    
    // Environment sphere
    const envGeometry = new THREE.SphereGeometry(100, 32, 32);
    const envMaterial = new THREE.MeshBasicMaterial({
      color: 0x0a0a0a,
      side: THREE.BackSide,
      transparent: true,
      opacity: 0.8
    });
    const envSphere = new THREE.Mesh(envGeometry, envMaterial);
    scene.add(envSphere);
    
    // Function to create irregular glass shard geometry
    function createShardGeometry() {
      const geometry = new THREE.BufferGeometry();
      const vertices = [];
      
      const points = 5 + Math.floor(Math.random() * 4);
      const baseSize = 1.5 + Math.random() * 2;
      
      const centerX = 0;
      const centerY = 0;
      
      const angleStep = (Math.PI * 2) / points;
      const shardPoints = [];
      
      for (let i = 0; i < points; i++) {
        const angle = angleStep * i + (Math.random() - 0.5) * 0.5;
        const radius = baseSize * (0.4 + Math.random() * 0.6);
        shardPoints.push({
          x: Math.cos(angle) * radius,
          y: Math.sin(angle) * radius
        });
      }
      
      for (let i = 0; i < points; i++) {
        const p1 = shardPoints[i];
        const p2 = shardPoints[(i + 1) % points];
        
        vertices.push(centerX, centerY, 0);
        vertices.push(p1.x, p1.y, 0);
        vertices.push(p2.x, p2.y, 0);
        
        vertices.push(centerX, centerY, 0);
        vertices.push(p2.x, p2.y, 0);
        vertices.push(p1.x, p1.y, 0);
      }
      
      geometry.setAttribute('position', new THREE.Float32BufferAttribute(vertices, 3));
      geometry.computeVertexNormals();
      
      return geometry;
    }
    
    // Create 5 glass shards
    const shards = [];
    const shardMeshes = [];
    
    for (let i = 0; i < 5; i++) {
      const geometry = createShardGeometry();
      
      const material = new THREE.MeshPhysicalMaterial({
        metalness: 1,
        roughness: 0.05,
        color: 0xcccccc,
        emissive: 0x000000,
        emissiveIntensity: 0,
        transparent: true,
        opacity: 0.85,
        side: THREE.DoubleSide,
        envMapIntensity: 1.5,
        reflectivity: 1
      });
      
      const shard = new THREE.Mesh(geometry, material);
      
      const angle = (i / 5) * Math.PI * 2;
      const radius = 12;
      shard.position.x = Math.cos(angle) * radius;
      shard.position.y = (Math.random() - 0.5) * 6;
      shard.position.z = Math.sin(angle) * radius;
      
      shard.rotation.x = Math.random() * Math.PI * 2;
      shard.rotation.y = Math.random() * Math.PI * 2;
      shard.rotation.z = Math.random() * Math.PI * 2;
      
      shard.userData = {
        projectId: i,
        orbitSpeed: 0.0003 + Math.random() * 0.0005,
        orbitAngle: angle,
        orbitRadius: radius,
        floatSpeed: 0.0008 + Math.random() * 0.0012,
        floatOffset: Math.random() * Math.PI * 2,
        rotationSpeedX: (Math.random() - 0.5) * 0.01,
        rotationSpeedY: (Math.random() - 0.5) * 0.01,
        rotationSpeedZ: (Math.random() - 0.5) * 0.008,
        originalY: shard.position.y,
        hovered: false
      };
      
      scene.add(shard);
      shardMeshes.push(shard);
      shards.push({
        mesh: shard,
        project: projects[i]
      });
    }
    
    // Project world creators
    function createNeuralAIWorld() {
      const objects = [];
      const color = 0x00ffff;
      
      // Neural network nodes
      const nodeGeometry = new THREE.SphereGeometry(0.3, 16, 16);
      const nodeMaterial = new THREE.MeshBasicMaterial({ 
        color: color,
        transparent: true,
        opacity: 0.8
      });
      
      // Create layers of nodes
      for (let layer = 0; layer < 4; layer++) {
        const nodesInLayer = 3 + layer;
        for (let i = 0; i < nodesInLayer; i++) {
          const node = new THREE.Mesh(nodeGeometry, nodeMaterial.clone());
          node.position.x = (i - nodesInLayer / 2) * 3;
          node.position.y = (Math.random() - 0.5) * 2;
          node.position.z = (layer - 1.5) * 5;
          node.userData = { 
            pulseSpeed: 1 + Math.random() * 2,
            pulseOffset: Math.random() * Math.PI * 2
          };
          scene.add(node);
          objects.push(node);
        }
      }
      
      // Connection lines
      const lineMaterial = new THREE.LineBasicMaterial({ 
        color: color,
        transparent: true,
        opacity: 0.3
      });
      
      for (let i = 0; i < 30; i++) {
        const points = [];
        const obj1 = objects[Math.floor(Math.random() * objects.length)];
        const obj2 = objects[Math.floor(Math.random() * objects.length)];
        points.push(obj1.position);
        points.push(obj2.position);
        const lineGeometry = new THREE.BufferGeometry().setFromPoints(points);
        const line = new THREE.Line(lineGeometry, lineMaterial);
        scene.add(line);
        objects.push(line);
      }
      
      return objects;
    }
    
    function createWebDashboardWorld() {
      const objects = [];
      const color = 0xff00ff;
      
      // Floating UI panels
      for (let i = 0; i < 8; i++) {
        const width = 2 + Math.random() * 2;
        const height = 1.5 + Math.random() * 1.5;
        const panelGeometry = new THREE.PlaneGeometry(width, height);
        const panelMaterial = new THREE.MeshBasicMaterial({
          color: color,
          transparent: true,
          opacity: 0.2,
          side: THREE.DoubleSide
        });
        
        const panel = new THREE.Mesh(panelGeometry, panelMaterial);
        const angle = (i / 8) * Math.PI * 2;
        panel.position.x = Math.cos(angle) * 6;
        panel.position.y = (Math.random() - 0.5) * 4;
        panel.position.z = Math.sin(angle) * 6;
        panel.lookAt(0, 0, 0);
        
        // Add glowing edge
        const edgeGeometry = new THREE.EdgesGeometry(panelGeometry);
        const edgeMaterial = new THREE.LineBasicMaterial({ color: color });
        const edges = new THREE.LineSegments(edgeGeometry, edgeMaterial);
        panel.add(edges);
        
        panel.userData = { 
          rotationSpeed: 0.005 + Math.random() * 0.01,
          angle: angle
        };
        
        scene.add(panel);
        objects.push(panel);
      }
      
      return objects;
    }
    
    function createGameEngineWorld() {
      const objects = [];
      const color = 0xffff00;
      
      // Voxel terrain
      const voxelSize = 0.8;
      const gridSize = 12;
      
      for (let x = -gridSize/2; x < gridSize/2; x++) {
        for (let z = -gridSize/2; z < gridSize/2; z++) {
          const height = Math.floor(Math.random() * 3) + 1;
          for (let y = 0; y < height; y++) {
            const voxelGeometry = new THREE.BoxGeometry(voxelSize, voxelSize, voxelSize);
            const voxelMaterial = new THREE.MeshPhongMaterial({
              color: color,
              transparent: true,
              opacity: 0.7,
              emissive: color,
              emissiveIntensity: 0.2
            });
            
            const voxel = new THREE.Mesh(voxelGeometry, voxelMaterial);
            voxel.position.set(x * voxelSize, y * voxelSize - 5, z * voxelSize);
            
            scene.add(voxel);
            objects.push(voxel);
          }
        }
      }
      
      return objects;
    }
    
    function createDataVizWorld() {
      const objects = [];
      const color = 0x00ff00;
      
      // Pulsating grid
      const gridSize = 20;
      const spacing = 1;
      
      for (let x = -gridSize/2; x < gridSize/2; x++) {
        for (let z = -gridSize/2; z < gridSize/2; z++) {
          const barHeight = 0.5 + Math.random() * 3;
          const barGeometry = new THREE.BoxGeometry(0.3, barHeight, 0.3);
          const barMaterial = new THREE.MeshPhongMaterial({
            color: color,
            emissive: color,
            emissiveIntensity: 0.5,
            transparent: true,
            opacity: 0.8
          });
          
          const bar = new THREE.Mesh(barGeometry, barMaterial);
          bar.position.set(x * spacing, barHeight / 2 - 3, z * spacing);
          bar.userData = { 
            originalHeight: barHeight,
            pulseSpeed: 0.5 + Math.random() * 1,
            pulseOffset: Math.random() * Math.PI * 2
          };
          
          scene.add(bar);
          objects.push(bar);
        }
      }
      
      return objects;
    }
    
    function createBlockchainWorld() {
      const objects = [];
      const color = 0xff6600;
      
      // Chain of blocks
      const blockCount = 12;
      
      for (let i = 0; i < blockCount; i++) {
        const blockGeometry = new THREE.BoxGeometry(1.5, 1.5, 1.5);
        const blockMaterial = new THREE.MeshPhongMaterial({
          color: color,
          emissive: color,
          emissiveIntensity: 0.3,
          transparent: true,
          opacity: 0.7
        });
        
        const block = new THREE.Mesh(blockGeometry, blockMaterial);
        const angle = (i / blockCount) * Math.PI * 2;
        const radius = 8;
        block.position.x = Math.cos(angle) * radius;
        block.position.y = Math.sin(i * 0.5) * 2;
        block.position.z = Math.sin(angle) * radius;
        
        block.rotation.x = Math.random() * Math.PI;
        block.rotation.y = Math.random() * Math.PI;
        
        block.userData = {
          rotationSpeed: 0.01,
          angle: angle,
          radius: radius
        };
        
        // Add wireframe
        const wireframeGeometry = new THREE.EdgesGeometry(blockGeometry);
        const wireframeMaterial = new THREE.LineBasicMaterial({ color: 0xffffff });
        const wireframe = new THREE.LineSegments(wireframeGeometry, wireframeMaterial);
        block.add(wireframe);
        
        scene.add(block);
        objects.push(block);
      }
      
      return objects;
    }
    
    function enterProjectWorld(projectId) {
      const fadeOverlay = document.getElementById('fade-overlay');
      
      // Fade to black
      fadeOverlay.classList.add('active');
      
      setTimeout(() => {
        currentMode = 'project';
        currentProjectId = projectId;
        
        // Hide shards
        shardMeshes.forEach(shard => {
          shard.visible = false;
        });
        
        // Create project world
        switch(projectId) {
          case 0:
            projectObjects = createNeuralAIWorld();
            scene.fog.color.setHex(0x001a1a);
            break;
          case 1:
            projectObjects = createWebDashboardWorld();
            scene.fog.color.setHex(0x1a001a);
            break;
          case 2:
            projectObjects = createGameEngineWorld();
            scene.fog.color.setHex(0x1a1a00);
            break;
          case 3:
            projectObjects = createDataVizWorld();
            scene.fog.color.setHex(0x001a00);
            break;
          case 4:
            projectObjects = createBlockchainWorld();
            scene.fog.color.setHex(0x1a0a00);
            break;
        }
        
        // Show project overlay
        const overlay = document.getElementById('project-overlay');
        const title = document.getElementById('project-title');
        const description = document.getElementById('project-description');
        
        title.textContent = projects[projectId].name;
        title.style.color = '#' + projects[projectId].color.toString(16).padStart(6, '0');
        description.textContent = projects[projectId].desc;
        overlay.classList.add('visible');
        
        // Zoom camera
        camera.position.z = 15;
        
        // Fade back in
        setTimeout(() => {
          fadeOverlay.classList.remove('active');
        }, 100);
      }, 800);
    }
    
    function exitProjectWorld() {
      const fadeOverlay = document.getElementById('fade-overlay');
      const overlay = document.getElementById('project-overlay');
      
      // Hide overlay first
      overlay.classList.remove('visible');
      
      // Fade to black
      fadeOverlay.classList.add('active');
      
      setTimeout(() => {
        currentMode = 'void';
        
        // Remove project objects
        projectObjects.forEach(obj => {
          scene.remove(obj);
          if (obj.geometry) obj.geometry.dispose();
          if (obj.material) {
            if (Array.isArray(obj.material)) {
              obj.material.forEach(mat => mat.dispose());
            } else {
              obj.material.dispose();
            }
          }
        });
        projectObjects = [];
        
        // Show shards
        shardMeshes.forEach(shard => {
          shard.visible = true;
          shard.material.emissive.setHex(0x000000);
          shard.material.emissiveIntensity = 0;
        });
        
        // Reset fog
        scene.fog.color.setHex(0x000000);
        
        // Reset camera
        camera.position.x = 0;
        camera.position.y = 0;
        camera.position.z = 20;
        
        currentProjectId = null;
        
        // Fade back in
        setTimeout(() => {
          fadeOverlay.classList.remove('active');
        }, 100);
      }, 800);
    }
    
    // Mouse interaction
    const mouse = new THREE.Vector2();
    const raycaster = new THREE.Raycaster();
    let hoveredShard = null;
    
    const label = document.getElementById('label');
    const labelName = document.getElementById('label-name');
    const labelDesc = document.getElementById('label-desc');
    
    window.addEventListener('mousemove', (event) => {
      mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
      mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
      
      if (currentMode === 'void') {
        camera.position.x += (mouse.x * 3 - camera.position.x) * 0.05;
        camera.position.y += (mouse.y * 3 - camera.position.y) * 0.05;
        camera.lookAt(0, 0, 0);
        
        raycaster.setFromCamera(mouse, camera);
        const intersects = raycaster.intersectObjects(shardMeshes);
        
        if (hoveredShard && (!intersects.length || intersects[0].object !== hoveredShard)) {
          hoveredShard.userData.hovered = false;
          hoveredShard.material.emissive.setHex(0x000000);
          hoveredShard.material.emissiveIntensity = 0;
          hoveredShard = null;
          label.classList.remove('visible');
        }
        
        if (intersects.length > 0) {
          const shard = intersects[0].object;
          if (shard !== hoveredShard) {
            hoveredShard = shard;
            shard.userData.hovered = true;
            const project = projects[shard.userData.projectId];
            shard.material.emissive.setHex(project.color);
            shard.material.emissiveIntensity = 0.6;
            
            const project = projects[shard.userData.projectId];
            labelName.textContent = project.name;
            labelDesc.textContent = project.desc;
            
            const vector = new THREE.Vector3();
            shard.getWorldPosition(vector);
            vector.project(camera);
            
            const x = (vector.x * 0.5 + 0.5) * window.innerWidth;
            const y = (-(vector.y * 0.5) + 0.5) * window.innerHeight;
            
            label.style.left = x + 'px';
            label.style.top = (y - 80) + 'px';
            label.classList.add('visible');
          }
        }
      }
    });
    
    window.addEventListener('click', () => {
      if (currentMode === 'void' && hoveredShard) {
        const projectId = hoveredShard.userData.projectId;
        enterProjectWorld(projectId);
      }
    });
    
    document.getElementById('back-button').addEventListener('click', () => {
      exitProjectWorld();
    });
    
    // Animation loop
    let time = 0;
    
    function animate() {
      requestAnimationFrame(animate);
      time += 0.016;
      
      if (currentMode === 'void') {
        shardMeshes.forEach(shard => {
          const data = shard.userData;
          
          data.orbitAngle += data.orbitSpeed;
          shard.position.x = Math.cos(data.orbitAngle) * data.orbitRadius;
          shard.position.z = Math.sin(data.orbitAngle) * data.orbitRadius;
          shard.position.y = data.originalY + Math.sin(time * data.floatSpeed + data.floatOffset) * 1.5;
          
          shard.rotation.x += data.rotationSpeedX;
          shard.rotation.y += data.rotationSpeedY;
          shard.rotation.z += data.rotationSpeedZ;
          
          const targetScale = data.hovered ? 1.3 : 1;
          shard.scale.x += (targetScale - shard.scale.x) * 0.1;
          shard.scale.y += (targetScale - shard.scale.y) * 0.1;
          shard.scale.z += (targetScale - shard.scale.z) * 0.1;
        });
        
        pointLight.position.x = Math.sin(time * 0.3) * 15;
        pointLight.position.z = Math.cos(time * 0.3) * 15;
        
        rimLight.position.x = Math.cos(time * 0.4) * 12;
        rimLight.position.y = Math.sin(time * 0.5) * 10;
      } else if (currentMode === 'project') {
        // Animate project worlds
        if (currentProjectId === 0) { // Neural AI
          projectObjects.forEach((obj, i) => {
            if (obj.geometry.type === 'SphereGeometry') {
              const pulse = Math.sin(time * obj.userData.pulseSpeed + obj.userData.pulseOffset);
              obj.scale.setScalar(1 + pulse * 0.2);
              obj.material.opacity = 0.6 + pulse * 0.2;
            }
          });
        } else if (currentProjectId === 1) { // Web Dashboard
          projectObjects.forEach(panel => {
            panel.userData.angle += panel.userData.rotationSpeed;
            panel.position.x = Math.cos(panel.userData.angle) * 6;
            panel.position.z = Math.sin(panel.userData.angle) * 6;
            panel.lookAt(0, 0, 0);
          });
        } else if (currentProjectId === 2) { // Game Engine
          projectObjects.forEach(voxel => {
            voxel.rotation.y = time * 0.2;
          });
        } else if (currentProjectId === 3) { // Data Viz
          projectObjects.forEach(bar => {
            const pulse = Math.sin(time * bar.userData.pulseSpeed + bar.userData.pulseOffset);
            const newHeight = bar.userData.originalHeight * (0.7 + pulse * 0.3);
            bar.scale.y = newHeight / bar.userData.originalHeight;
            bar.position.y = newHeight / 2 - 3;
            bar.material.emissiveIntensity = 0.3 + pulse * 0.3;
          });
        } else if (currentProjectId === 4) { // Blockchain
          projectObjects.forEach(block => {
            block.rotation.x += block.userData.rotationSpeed;
            block.rotation.y += block.userData.rotationSpeed * 0.7;
            block.userData.angle += 0.001;
            block.position.x = Math.cos(block.userData.angle) * block.userData.radius;
            block.position.z = Math.sin(block.userData.angle) * block.userData.radius;
          });
        }
        
        camera.lookAt(0, 0, 0);
      }
      
      renderer.render(scene, camera);
    }
    
    animate();
    
    window.addEventListener('resize', () => {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    });
  </script>
</body>
</html>