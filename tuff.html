// Create debris shards (smaller pieces for depth)
    for (let i = 0; i < 25; i++) {
      const geometry = createShardGeometry();
      const material = new THREE.MeshPhysicalMaterial({
        metal<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Reflective Void Portfolio</title>
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }
    
    body {
      font-family: 'Courier New', monospace;
      background: #fff;
      overflow: hidden;
      cursor: default;
      user-select: none;
    }
    
    #canvas {
      display: block;
      width: 100vw;
      height: 100vh;
      position: fixed;
      top: 0;
      left: 0;
    }
    
    .label {
      position: absolute;
      color: black;
      font-size: 24px;
      font-weight: 100;
      letter-spacing: 4px;
      pointer-events: none;
      opacity: 0;
      transition: opacity 0.3s;
      text-shadow: 0 0 20px rgba(0,0,0,0.3);
      transform: translate(-50%, -50%);
    }
    
    .label.visible {
      opacity: 1;
    }
    
    .label-desc {
      font-size: 12px;
      opacity: 0.6;
      letter-spacing: 2px;
      margin-top: 8px;
    }
    
    .footer {
      position: absolute;
      bottom: 20px;
      left: 50%;
      transform: translateX(-50%);
      color: black;
      font-size: 10px;
      letter-spacing: 3px;
      opacity: 0.3;
    }
    
    .project-overlay {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      color: white;
      opacity: 0;
      pointer-events: none;
      transition: opacity 1s;
      z-index: 10;
      background: rgba(0, 0, 0, 0.7);
    }
    
    .project-overlay.visible {
      opacity: 1;
      pointer-events: all;
    }
    
    .fade-overlay {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: black;
      opacity: 0;
      pointer-events: none;
      transition: opacity 0.8s;
      z-index: 5;
    }
    
    .fade-overlay.active {
      opacity: 1;
    }
    
    .project-title {
      font-size: 48px;
      letter-spacing: 8px;
      margin-bottom: 16px;
      text-shadow: 0 0 30px currentColor;
    }
    
    .project-description {
      font-size: 16px;
      letter-spacing: 3px;
      opacity: 0.7;
      margin-bottom: 32px;
    }
    
    .back-button {
      padding: 12px 32px;
      border: 2px solid white;
      background: transparent;
      color: white;
      font-family: 'Courier New', monospace;
      font-size: 14px;
      letter-spacing: 3px;
      cursor: pointer;
      transition: all 0.3s;
      margin-top: 20px;
    }
    
    .back-button:hover {
      background: white;
      color: black;
      box-shadow: 0 0 20px white;
    }
  </style>
</head>
<body>
  <canvas id="canvas"></canvas>
  <div id="label" class="label">
    <div id="label-name"></div>
    <div class="label-desc" id="label-desc"></div>
  </div>
  
  <div id="project-overlay" class="project-overlay">
    <div class="project-title" id="project-title"></div>
    <div class="project-description" id="project-description"></div>
    <button class="back-button" id="back-button">← RETURN TO VOID</button>
  </div>
  
  <div id="fade-overlay" class="fade-overlay"></div>
  
  <div class="footer">ACHYUT V KUMAR • PORTFOLIO 2025</div>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
  
  <script>
    // Scene setup
    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0xffffff);
    scene.fog = new THREE.FogExp2(0xffffff, 0.015);
    
    const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
    camera.position.set(0, 5, 25);
    camera.lookAt(0, 0, 0);
    
    const renderer = new THREE.WebGLRenderer({ 
      canvas: document.getElementById('canvas'),
      antialias: true,
      alpha: true 
    });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
    renderer.toneMapping = THREE.ACESFilmicToneMapping;
    renderer.toneMappingExposure = 1.2;
    
    // Projects data
    const projects = [
      { name: 'NEURAL AI', desc: 'Machine Learning Pipeline', color: 0x00ffff },
      { name: 'WEB DASHBOARD', desc: 'Real-time Analytics', color: 0xff00ff },
      { name: 'GAME ENGINE', desc: 'Voxel World Builder', color: 0xffff00 },
      { name: 'DATA VIZ', desc: 'Interactive Charts', color: 0x00ff00 },
      { name: 'BLOCKCHAIN', desc: 'Smart Contract System', color: 0xff6600 }
    ];
    
    // State management
    let currentMode = 'void';
    let currentProjectId = null;
    let projectObjects = [];
    let debrisShards = [];
    
    // Lighting - Cool blue-white key light
    const ambientLight = new THREE.AmbientLight(0x1a1a2e, 0.2);
    scene.add(ambientLight);
    
    const keyLight = new THREE.PointLight(0xaaddff, 2.5, 100);
    keyLight.position.set(8, 12, 8);
    scene.add(keyLight);
    
    const rimLight = new THREE.PointLight(0x4488ff, 1.2, 50);
    rimLight.position.set(-8, 8, -8);
    scene.add(rimLight);
    
    const fillLight = new THREE.PointLight(0x88aaff, 0.8, 40);
    fillLight.position.set(0, 5, -10);
    scene.add(fillLight);
    
    // Obsidian floor
    const floorGeometry = new THREE.PlaneGeometry(200, 200);
    const floorMaterial = new THREE.MeshPhysicalMaterial({
      metalness: 0.9,
      roughness: 0.6,
      color: 0x050505,
      clearcoat: 1,
      clearcoatRoughness: 0.3,
      reflectivity: 0.7,
      envMapIntensity: 0.5
    });
    const floor = new THREE.Mesh(floorGeometry, floorMaterial);
    floor.rotation.x = -Math.PI / 2;
    floor.position.y = -5;
    scene.add(floor);
    
    // Mist particles
    const particleCount = 800;
    const particleGeometry = new THREE.BufferGeometry();
    const positions = new Float32Array(particleCount * 3);
    
    for (let i = 0; i < particleCount * 3; i += 3) {
      positions[i] = (Math.random() - 0.5) * 100;
      positions[i + 1] = Math.random() * 40 - 5;
      positions[i + 2] = (Math.random() - 0.5) * 100;
    }
    
    particleGeometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
    
    const particleMaterial = new THREE.PointsMaterial({
      color: 0x6699bb,
      size: 0.08,
      opacity: 0.12,
      transparent: true,
      depthWrite: false,
      blending: THREE.AdditiveBlending
    });
    
    const particles = new THREE.Points(particleGeometry, particleMaterial);
    scene.add(particles);
    
    // Function to create irregular glass shard geometry
    function createShardGeometry() {
      const geometry = new THREE.BufferGeometry();
      const vertices = [];
      
      const points = 5 + Math.floor(Math.random() * 4);
      const baseSize = 1.5 + Math.random() * 2;
      
      const centerX = 0;
      const centerY = 0;
      
      const angleStep = (Math.PI * 2) / points;
      const shardPoints = [];
      
      for (let i = 0; i < points; i++) {
        const angle = angleStep * i + (Math.random() - 0.5) * 0.5;
        const radius = baseSize * (0.4 + Math.random() * 0.6);
        shardPoints.push({
          x: Math.cos(angle) * radius,
          y: Math.sin(angle) * radius
        });
      }
      
      for (let i = 0; i < points; i++) {
        const p1 = shardPoints[i];
        const p2 = shardPoints[(i + 1) % points];
        
        vertices.push(centerX, centerY, 0);
        vertices.push(p1.x, p1.y, 0);
        vertices.push(p2.x, p2.y, 0);
        
        vertices.push(centerX, centerY, 0);
        vertices.push(p2.x, p2.y, 0);
        vertices.push(p1.x, p1.y, 0);
      }
      
      geometry.setAttribute('position', new THREE.Float32BufferAttribute(vertices, 3));
      geometry.computeVertexNormals();
      
      return geometry;
    }
    
    // Create 5 glass shards with enhanced material
    const shards = [];
    const shardMeshes = [];
    
    for (let i = 0; i < 5; i++) {
      const geometry = createShardGeometry();
      
      const material = new THREE.MeshPhysicalMaterial({
        metalness: 1,
        roughness: 0.05,
        transmission: 0.1,
        thickness: 0.8, // Increased depth for shards
        reflectivity: 1,
        clearcoat: 1,
        clearcoatRoughness: 0.05,
        color: 0xcccccc,
        emissive: 0x000000,
        emissiveIntensity: 0,
        transparent: true,
        opacity: 0.9,
        side: THREE.DoubleSide,
        envMapIntensity: 1.5
      });
      
      const shard = new THREE.Mesh(geometry, material);
      
      const angle = (i / 5) * Math.PI * 2;
      const radius = 12;
      shard.position.x = Math.cos(angle) * radius;
      shard.position.y = (Math.random() - 0.5) * 4;
      shard.position.z = Math.sin(angle) * radius;
      
      shard.rotation.x = Math.random() * Math.PI * 2;
      shard.rotation.y = Math.random() * Math.PI * 2;
      shard.rotation.z = Math.random() * Math.PI * 2;
      
      shard.userData = {
        projectId: i,
        orbitSpeed: 0.0002 + Math.random() * 0.0003,
        orbitAngle: angle,
        orbitRadius: radius,
        floatSpeed: 0.0005 + Math.random() * 0.0008,
        floatOffset: Math.random() * Math.PI * 2,
        rotationSpeedX: (Math.random() - 0.5) * 0.001,
        rotationSpeedY: (Math.random() - 0.5) * 0.0007,
        rotationSpeedZ: (Math.random() - 0.5) * 0.0005,
        originalY: shard.position.y,
        hovered: false
      };
      
      scene.add(shard);
      shardMeshes.push(shard);
      shards.push({
        mesh: shard,
        project: projects[i]
      });
    }
    
    // Create debris shards (smaller pieces for depth)
    for (let i = 0; i < 25; i++) {
      const geometry = createShardGeometry();
      const material = new THREE.MeshPhysicalMaterial({
        metalness: 1,
        roughness: 0.08,
        transmission: 0.15,
        thickness: 0.5, // Increased depth
        reflectivity: 1,
        clearcoat: 0.8,
        clearcoatRoughness: 0.1,
        color: 0xaaaaaa,
        transparent: true,
        opacity: 0.5,
        side: THREE.DoubleSide,
        envMapIntensity: 1.2
      });
      
      const debris = new THREE.Mesh(geometry, material);
      debris.scale.setScalar(0.25 + Math.random() * 0.35);
      
      const angle = (i / 25) * Math.PI * 2;
      const radius = 6 + Math.random() * 10;
      debris.position.x = Math.cos(angle) * radius;
      debris.position.y = Math.max(-4, (Math.random() - 0.5) * 12); // Prevent spawning below floor
      debris.position.z = Math.sin(angle) * radius;
      
      debris.rotation.x = Math.random() * Math.PI * 2;
      debris.rotation.y = Math.random() * Math.PI * 2;
      debris.rotation.z = Math.random() * Math.PI * 2;
      
      debris.userData = {
        orbitSpeed: 0.0001 + Math.random() * 0.0003,
        orbitAngle: angle,
        orbitRadius: radius,
        floatSpeed: 0.0008 + Math.random() * 0.0015,
        floatOffset: Math.random() * Math.PI * 2,
        rotationSpeedX: (Math.random() - 0.5) * 0.002,
        rotationSpeedY: (Math.random() - 0.5) * 0.002,
        rotationSpeedZ: (Math.random() - 0.5) * 0.0015,
        originalY: debris.position.y
      };
      
      scene.add(debris);
      debrisShards.push(debris);
    }
    
    // Project world creators
    function createNeuralAIWorld() {
      const objects = [];
      const color = 0x00ffff;
      
      const nodeGeometry = new THREE.SphereGeometry(0.3, 16, 16);
      const nodeMaterial = new THREE.MeshBasicMaterial({ 
        color: color,
        transparent: true,
        opacity: 0.8
      });
      
      for (let layer = 0; layer < 4; layer++) {
        const nodesInLayer = 3 + layer;
        for (let i = 0; i < nodesInLayer; i++) {
          const node = new THREE.Mesh(nodeGeometry, nodeMaterial.clone());
          node.position.x = (i - nodesInLayer / 2) * 3;
          node.position.y = (Math.random() - 0.5) * 2;
          node.position.z = (layer - 1.5) * 5;
          node.userData = { 
            pulseSpeed: 1 + Math.random() * 2,
            pulseOffset: Math.random() * Math.PI * 2
          };
          scene.add(node);
          objects.push(node);
        }
      }
      
      const lineMaterial = new THREE.LineBasicMaterial({ 
        color: color,
        transparent: true,
        opacity: 0.3
      });
      
      for (let i = 0; i < 30; i++) {
        const points = [];
        const obj1 = objects[Math.floor(Math.random() * objects.length)];
        const obj2 = objects[Math.floor(Math.random() * objects.length)];
        points.push(obj1.position);
        points.push(obj2.position);
        const lineGeometry = new THREE.BufferGeometry().setFromPoints(points);
        const line = new THREE.Line(lineGeometry, lineMaterial);
        scene.add(line);
        objects.push(line);
      }
      
      return objects;
    }
    
    function createWebDashboardWorld() {
      const objects = [];
      const color = 0xff00ff;
      
      for (let i = 0; i < 8; i++) {
        const width = 2 + Math.random() * 2;
        const height = 1.5 + Math.random() * 1.5;
        const panelGeometry = new THREE.PlaneGeometry(width, height);
        const panelMaterial = new THREE.MeshBasicMaterial({
          color: color,
          transparent: true,
          opacity: 0.2,
          side: THREE.DoubleSide
        });
        
        const panel = new THREE.Mesh(panelGeometry, panelMaterial);
        const angle = (i / 8) * Math.PI * 2;
        panel.position.x = Math.cos(angle) * 6;
        panel.position.y = (Math.random() - 0.5) * 4;
        panel.position.z = Math.sin(angle) * 6;
        panel.lookAt(0, 0, 0);
        
        const edgeGeometry = new THREE.EdgesGeometry(panelGeometry);
        const edgeMaterial = new THREE.LineBasicMaterial({ color: color });
        const edges = new THREE.LineSegments(edgeGeometry, edgeMaterial);
        panel.add(edges);
        
        panel.userData = { 
          rotationSpeed: 0.005 + Math.random() * 0.01,
          angle: angle
        };
        
        scene.add(panel);
        objects.push(panel);
      }
      
      return objects;
    }
    
    function createGameEngineWorld() {
      const objects = [];
      const color = 0xffff00;
      
      const voxelSize = 0.8;
      const gridSize = 12;
      
      for (let x = -gridSize/2; x < gridSize/2; x++) {
        for (let z = -gridSize/2; z < gridSize/2; z++) {
          const height = Math.floor(Math.random() * 3) + 1;
          for (let y = 0; y < height; y++) {
            const voxelGeometry = new THREE.BoxGeometry(voxelSize, voxelSize, voxelSize);
            const voxelMaterial = new THREE.MeshPhongMaterial({
              color: color,
              transparent: true,
              opacity: 0.7,
              emissive: color,
              emissiveIntensity: 0.2
            });
            
            const voxel = new THREE.Mesh(voxelGeometry, voxelMaterial);
            voxel.position.set(x * voxelSize, y * voxelSize - 5, z * voxelSize);
            
            scene.add(voxel);
            objects.push(voxel);
          }
        }
      }
      
      return objects;
    }
    
    function createDataVizWorld() {
      const objects = [];
      const color = 0x00ff00;
      
      const gridSize = 20;
      const spacing = 1;
      
      for (let x = -gridSize/2; x < gridSize/2; x++) {
        for (let z = -gridSize/2; z < gridSize/2; z++) {
          const barHeight = 0.5 + Math.random() * 3;
          const barGeometry = new THREE.BoxGeometry(0.3, barHeight, 0.3);
          const barMaterial = new THREE.MeshPhongMaterial({
            color: color,
            emissive: color,
            emissiveIntensity: 0.5,
            transparent: true,
            opacity: 0.8
          });
          
          const bar = new THREE.Mesh(barGeometry, barMaterial);
          bar.position.set(x * spacing, barHeight / 2 - 3, z * spacing);
          bar.userData = { 
            originalHeight: barHeight,
            pulseSpeed: 0.5 + Math.random() * 1,
            pulseOffset: Math.random() * Math.PI * 2
          };
          
          scene.add(bar);
          objects.push(bar);
        }
      }
      
      return objects;
    }
    
    function createBlockchainWorld() {
      const objects = [];
      const color = 0xff6600;
      
      const blockCount = 12;
      
      for (let i = 0; i < blockCount; i++) {
        const blockGeometry = new THREE.BoxGeometry(1.5, 1.5, 1.5);
        const blockMaterial = new THREE.MeshPhongMaterial({
          color: color,
          emissive: color,
          emissiveIntensity: 0.3,
          transparent: true,
          opacity: 0.7
        });
        
        const block = new THREE.Mesh(blockGeometry, blockMaterial);
        const angle = (i / blockCount) * Math.PI * 2;
        const radius = 8;
        block.position.x = Math.cos(angle) * radius;
        block.position.y = Math.sin(i * 0.5) * 2;
        block.position.z = Math.sin(angle) * radius;
        
        block.rotation.x = Math.random() * Math.PI;
        block.rotation.y = Math.random() * Math.PI;
        
        block.userData = {
          rotationSpeed: 0.01,
          angle: angle,
          radius: radius
        };
        
        const wireframeGeometry = new THREE.EdgesGeometry(blockGeometry);
        const wireframeMaterial = new THREE.LineBasicMaterial({ color: 0xffffff });
        const wireframe = new THREE.LineSegments(wireframeGeometry, wireframeMaterial);
        block.add(wireframe);
        
        scene.add(block);
        objects.push(block);
      }
      
      return objects;
    }
    
    function enterProjectWorld(projectId) {
      const fadeOverlay = document.getElementById('fade-overlay');
      
      fadeOverlay.classList.add('active');
      
      setTimeout(() => {
        currentMode = 'project';
        currentProjectId = projectId;
        
        shardMeshes.forEach(shard => {
          shard.visible = false;
        });
        
        debrisShards.forEach(debris => {
          debris.visible = false;
        });
        
        switch(projectId) {
          case 0:
            projectObjects = createNeuralAIWorld();
            scene.fog.color.setHex(0x001a1a);
            break;
          case 1:
            projectObjects = createWebDashboardWorld();
            scene.fog.color.setHex(0x1a001a);
            break;
          case 2:
            projectObjects = createGameEngineWorld();
            scene.fog.color.setHex(0x1a1a00);
            break;
          case 3:
            projectObjects = createDataVizWorld();
            scene.fog.color.setHex(0x001a00);
            break;
          case 4:
            projectObjects = createBlockchainWorld();
            scene.fog.color.setHex(0x1a0a00);
            break;
        }
        
        const overlay = document.getElementById('project-overlay');
        const title = document.getElementById('project-title');
        const description = document.getElementById('project-description');
        
        title.textContent = projects[projectId].name;
        title.style.color = '#' + projects[projectId].color.toString(16).padStart(6, '0');
        description.textContent = projects[projectId].desc;
        overlay.classList.add('visible');
        
        camera.position.z = 15;
        
        setTimeout(() => {
          fadeOverlay.classList.remove('active');
        }, 100);
      }, 800);
    }
    
    function exitProjectWorld() {
      const fadeOverlay = document.getElementById('fade-overlay');
      const overlay = document.getElementById('project-overlay');
      
      overlay.classList.remove('visible');
      
      fadeOverlay.classList.add('active');
      
      setTimeout(() => {
        currentMode = 'void';
        
        projectObjects.forEach(obj => {
          scene.remove(obj);
          if (obj.geometry) obj.geometry.dispose();
          if (obj.material) {
            if (Array.isArray(obj.material)) {
              obj.material.forEach(mat => mat.dispose());
            } else {
              obj.material.dispose();
            }
          }
        });
        projectObjects = [];
        
        shardMeshes.forEach(shard => {
          shard.visible = true;
          shard.material.emissive.setHex(0x000000);
          shard.material.emissiveIntensity = 0;
        });
        
        debrisShards.forEach(debris => {
          debris.visible = true;
        });
        
        scene.fog.color.setHex(0xffffff);
        
        // Reset camera to initial spherical position
        cameraRotation.theta = 0;
        cameraRotation.phi = Math.PI / 8;
        cameraDistance = 25;
        updateCameraPosition();
        
        currentProjectId = null;
        
        setTimeout(() => {
          fadeOverlay.classList.remove('active');
        }, 100);
      }, 800);
    }
    
    // Mouse interaction and camera controls
    const mouse = new THREE.Vector2();
    const raycaster = new THREE.Raycaster();
    let hoveredShard = null;
    let hoveredDebris = null;
    let connectionLines = [];
    let lineAnimations = [];
    let draggedObject = null;
    let dragPlane = new THREE.Plane(new THREE.Vector3(0, 1, 0), 0);
    let dragOffset = new THREE.Vector3();
    let dragConnections = [];
    
    const label = document.getElementById('label');
    const labelName = document.getElementById('label-name');
    const labelDesc = document.getElementById('label-desc');
    
    // Function to find nearest shard to a position
    function findNearestShard(position, shardArray) {
      let nearest = null;
      let minDistance = Infinity;
      
      shardArray.forEach(shard => {
        const distance = position.distanceTo(shard.position);
        if (distance < minDistance) {
          minDistance = distance;
          nearest = shard;
        }
      });
      
      return nearest;
    }
    
    // Function to create connection lines
    function createConnectionLines() {
      // Mark existing lines for fade out
      connectionLines.forEach(lineData => {
        if (!lineData.fadingOut) {
          lineData.fadingOut = true;
          lineData.fadeStartTime = Date.now();
        }
      });
      
      if (!hoveredDebris) return;
      
      // Create chained connections from debris to debris to main shard
      let currentDebris = hoveredDebris;
      const processedDebris = new Set([hoveredDebris]);
      
      const waypoints = [hoveredDebris];
      let targetShard = null;
      
      // Build the path
      for (let i = 0; i < 5; i++) {
        const nearestShard = findNearestShard(currentDebris.position, shardMeshes);
        const nearestDebris = findNearestShard(
          currentDebris.position, 
          debrisShards.filter(d => !processedDebris.has(d))
        );
        
        const distToShard = currentDebris.position.distanceTo(nearestShard.position);
        const distToDebris = nearestDebris ? currentDebris.position.distanceTo(nearestDebris.position) : Infinity;
        
        if (distToShard < distToDebris || !nearestDebris) {
          waypoints.push(nearestShard);
          targetShard = nearestShard;
          break;
        } else {
          waypoints.push(nearestDebris);
          processedDebris.add(nearestDebris);
          currentDebris = nearestDebris;
        }
      }
      
      // Create white dots at each waypoint (except the last one which is the shard)
      waypoints.forEach((waypoint, index) => {
        if (index < waypoints.length - 1) { // Don't add dot to final shard
          const dotGeometry = new THREE.SphereGeometry(0.15, 8, 8);
          const dotMaterial = new THREE.MeshBasicMaterial({ 
            color: 0xffffff,
            transparent: true,
            opacity: 0
          });
          const dot = new THREE.Mesh(dotGeometry, dotMaterial);
          dot.position.copy(waypoint.position);
          scene.add(dot);
          
          connectionLines.push({
            isDot: true,
            mesh: dot,
            material: dotMaterial,
            waypoint: waypoint,
            waypointIndex: index,
            fadingOut: false,
            fadeStartTime: 0
          });
        }
      });
      
      // Create white lines connecting all dots
      for (let i = 0; i < waypoints.length - 1; i++) {
        const startWaypoint = waypoints[i];
        const endWaypoint = waypoints[i + 1];
        
        const dotLineGeometry = new THREE.BufferGeometry().setFromPoints([
          startWaypoint.position.clone(),
          endWaypoint.position.clone()
        ]);
        const dotLineMaterial = new THREE.LineBasicMaterial({ 
          color: 0xffffff,
          transparent: true,
          opacity: 0,
          linewidth: 2
        });
        
        const dotLine = new THREE.Line(dotLineGeometry, dotLineMaterial);
        scene.add(dotLine);
        
        connectionLines.push({
          isDotLine: true,
          line: dotLine,
          geometry: dotLineGeometry,
          material: dotLineMaterial,
          startWaypoint: startWaypoint,
          endWaypoint: endWaypoint,
          fadingOut: false,
          fadeStartTime: 0
        });
      }
      
      // Create glow for target shard with white outline
      if (targetShard) {
        const glowGeometry = targetShard.geometry.clone();
        const glowMaterial = new THREE.MeshBasicMaterial({
          color: 0xffffff,
          transparent: true,
          opacity: 0,
          side: THREE.BackSide
        });
        const glowMesh = new THREE.Mesh(glowGeometry, glowMaterial);
        glowMesh.position.copy(targetShard.position);
        glowMesh.rotation.copy(targetShard.rotation);
        glowMesh.scale.copy(targetShard.scale).multiplyScalar(1.5);
        scene.add(glowMesh);
        
        connectionLines.push({
          isGlow: true,
          mesh: glowMesh,
          material: glowMaterial,
          targetShard: targetShard,
          originalPosition: targetShard.position.clone(),
          originalScale: targetShard.scale.clone(),
          fadingOut: false,
          fadeStartTime: 0,
          glitchActive: false,
          glitchTimer: 0
        });
      }
      
      // Create one continuous line with all waypoints
      const startPos = waypoints[0].position.clone();
      
      // Create black outline (thicker)
      const outlinePoints = [startPos];
      const outlineGeometry = new THREE.BufferGeometry().setFromPoints(outlinePoints);
      const outlineMaterial = new THREE.LineBasicMaterial({ 
        color: 0x000000,
        transparent: true,
        opacity: 0.9,
        linewidth: 12
      });
      
      const outlineLine = new THREE.Line(outlineGeometry, outlineMaterial);
      scene.add(outlineLine);
      
      // Create white center line (thinner)
      const centerPoints = [startPos];
      const centerGeometry = new THREE.BufferGeometry().setFromPoints(centerPoints);
      const centerMaterial = new THREE.LineBasicMaterial({ 
        color: 0xffffff,
        transparent: true,
        opacity: 0.9,
        linewidth: 6
      });
      
      const centerLine = new THREE.Line(centerGeometry, centerMaterial);
      scene.add(centerLine);
      
      const lineData = {
        outlineLine: outlineLine,
        centerLine: centerLine,
        outlineGeometry: outlineGeometry,
        centerGeometry: centerGeometry,
        outlineMaterial: outlineMaterial,
        centerMaterial: centerMaterial,
        waypoints: waypoints,
        progress: 0,
        startTime: Date.now(),
        fadingOut: false,
        fadeStartTime: 0
      };
      
      connectionLines.push(lineData);
      lineAnimations.push(lineData);
    }
    
    // Camera control variables
    let isDragging = false;
    let previousMousePosition = { x: 0, y: 0 };
    let cameraRotation = { theta: 0, phi: Math.PI / 8 }; // theta: horizontal, phi: vertical
    let cameraDistance = 25;
    const MIN_DISTANCE = 8;
    const MAX_DISTANCE = 50;
    const MIN_PHI = 0.1; // Prevent going below ground (90 degrees from flat)
    const MAX_PHI = Math.PI / 2 - 0.1; // Limit upward angle
    
    function updateCameraPosition() {
      camera.position.x = cameraDistance * Math.sin(cameraRotation.phi) * Math.cos(cameraRotation.theta);
      camera.position.y = cameraDistance * Math.cos(cameraRotation.phi);
      camera.position.z = cameraDistance * Math.sin(cameraRotation.phi) * Math.sin(cameraRotation.theta);
      camera.lookAt(0, 0, 0);
    }
    
    window.addEventListener('mousedown', (event) => {
      if (currentMode === 'void') {
        raycaster.setFromCamera(mouse, camera);
        
        // Check if clicking on a shard or debris
        const shardIntersects = raycaster.intersectObjects(shardMeshes);
        const debrisIntersects = raycaster.intersectObjects(debrisShards);
        
        if (shardIntersects.length > 0) {
          draggedObject = shardIntersects[0].object;
          draggedObject.userData.isDragging = true;
          draggedObject.userData.originalPosition = draggedObject.position.clone();
          
          // Find 3-5 random debris pieces to pull it back
          const numConnections = 3 + Math.floor(Math.random() * 3);
          dragConnections = [];
          
          const shuffledDebris = [...debrisShards].sort(() => Math.random() - 0.5);
          for (let i = 0; i < Math.min(numConnections, shuffledDebris.length); i++) {
            dragConnections.push(shuffledDebris[i]);
          }
          
          // Calculate intersection with drag plane
          dragPlane.setFromNormalAndCoplanarPoint(
            camera.getWorldDirection(dragPlane.normal),
            draggedObject.position
          );
          
          const intersection = new THREE.Vector3();
          raycaster.ray.intersectPlane(dragPlane, intersection);
          dragOffset.copy(draggedObject.position).sub(intersection);
          
          label.classList.remove('visible');
          event.preventDefault();
        } else if (debrisIntersects.length > 0) {
          draggedObject = debrisIntersects[0].object;
          draggedObject.userData.isDragging = true;
          draggedObject.userData.originalPosition = draggedObject.position.clone();
          
          // Find 3-5 random debris pieces to pull it back
          const numConnections = 3 + Math.floor(Math.random() * 3);
          dragConnections = [];
          
          const shuffledDebris = [...debrisShards].filter(d => d !== draggedObject).sort(() => Math.random() - 0.5);
          for (let i = 0; i < Math.min(numConnections, shuffledDebris.length); i++) {
            dragConnections.push(shuffledDebris[i]);
          }
          
          // Calculate intersection with drag plane
          dragPlane.setFromNormalAndCoplanarPoint(
            camera.getWorldDirection(dragPlane.normal),
            draggedObject.position
          );
          
          const intersection = new THREE.Vector3();
          raycaster.ray.intersectPlane(dragPlane, intersection);
          dragOffset.copy(draggedObject.position).sub(intersection);
          
          event.preventDefault();
        } else {
          isDragging = true;
          previousMousePosition = { x: event.clientX, y: event.clientY };
          document.body.style.cursor = 'grabbing';
        }
      }
    });
    
    window.addEventListener('mouseup', () => {
      if (draggedObject) {
        draggedObject.userData.isDragging = false;
        draggedObject = null;
        dragConnections = [];
      }
      isDragging = false;
      document.body.style.cursor = 'default';
    });
    
    window.addEventListener('wheel', (event) => {
      if (currentMode === 'void') {
        event.preventDefault();
        cameraDistance += event.deltaY * 0.01;
        cameraDistance = Math.max(MIN_DISTANCE, Math.min(MAX_DISTANCE, cameraDistance));
        updateCameraPosition();
      }
    }, { passive: false });
    
    window.addEventListener('mousemove', (event) => {
      mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
      mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
      
      if (currentMode === 'void') {
        // Handle object dragging
        if (draggedObject) {
          raycaster.setFromCamera(mouse, camera);
          const intersection = new THREE.Vector3();
          raycaster.ray.intersectPlane(dragPlane, intersection);
          draggedObject.position.copy(intersection.add(dragOffset));
          
          // Add subtle rotation while dragging
          const dragSpeed = new THREE.Vector3().subVectors(
            draggedObject.position,
            draggedObject.userData.lastDragPosition || draggedObject.position
          ).length();
          
          draggedObject.rotation.y += dragSpeed * 0.5;
          draggedObject.rotation.x += dragSpeed * 0.3;
          
          draggedObject.userData.lastDragPosition = draggedObject.position.clone();
        } else if (isDragging) {
          const deltaX = event.clientX - previousMousePosition.x;
          const deltaY = event.clientY - previousMousePosition.y;
          
          cameraRotation.theta -= deltaX * 0.005;
          cameraRotation.phi += deltaY * 0.005;
          
          // Clamp phi to prevent going through floor
          cameraRotation.phi = Math.max(MIN_PHI, Math.min(MAX_PHI, cameraRotation.phi));
          
          updateCameraPosition();
          
          previousMousePosition = { x: event.clientX, y: event.clientY };
        }
        
        // Move key light with cursor
        keyLight.position.x = 8 + mouse.x * 5;
        keyLight.position.z = 8 + mouse.y * 5;
        
        if (!draggedObject && !isDragging) {
          raycaster.setFromCamera(mouse, camera);
          
          // Check for shard intersections
          const shardIntersects = raycaster.intersectObjects(shardMeshes);
          
          if (hoveredShard && (!shardIntersects.length || shardIntersects[0].object !== hoveredShard)) {
            hoveredShard.userData.hovered = false;
            hoveredShard.material.emissive.setHex(0x000000);
            hoveredShard.material.emissiveIntensity = 0;
            hoveredShard = null;
            label.classList.remove('visible');
          }
          
          if (shardIntersects.length > 0) {
            const shard = shardIntersects[0].object;
            if (shard !== hoveredShard) {
              hoveredShard = shard;
              shard.userData.hovered = true;
              const project = projects[shard.userData.projectId];
              shard.material.emissive.setHex(project.color);
              shard.material.emissiveIntensity = 0.8;
              
              labelName.textContent = project.name;
              labelDesc.textContent = project.desc;
              
              const vector = new THREE.Vector3();
              shard.getWorldPosition(vector);
              vector.project(camera);
              
              const x = (vector.x * 0.5 + 0.5) * window.innerWidth;
              const y = (-(vector.y * 0.5) + 0.5) * window.innerHeight;
              
              label.style.left = x + 'px';
              label.style.top = (y - 80) + 'px';
              label.classList.add('visible');
            }
          }
          
          // Check for debris intersections
          const debrisIntersects = raycaster.intersectObjects(debrisShards);
          
          if (hoveredDebris && (!debrisIntersects.length || debrisIntersects[0].object !== hoveredDebris)) {
            hoveredDebris = null;
            // Mark lines for fade out instead of clearing immediately
            connectionLines.forEach(lineData => {
              if (!lineData.fadingOut) {
                lineData.fadingOut = true;
                lineData.fadeStartTime = Date.now();
              }
            });
            lineAnimations.forEach(lineData => {
              if (!lineData.fadingOut) {
                lineData.fadingOut = true;
                lineData.fadeStartTime = Date.now();
              }
            });
          }
          
          if (debrisIntersects.length > 0) {
            const debris = debrisIntersects[0].object;
            if (debris !== hoveredDebris) {
              hoveredDebris = debris;
              createConnectionLines();
            }
          }
        }
      }
    });
    
    window.addEventListener('click', () => {
      if (currentMode === 'void' && hoveredShard && !isDragging) {
        label.classList.remove('visible');
        const projectId = hoveredShard.userData.projectId;
        enterProjectWorld(projectId);
      }
    });
    
    document.getElementById('back-button').addEventListener('click', () => {
      exitProjectWorld();
    });
    
    // Animation loop
    let time = 0;
    
    function animate() {
      requestAnimationFrame(animate);
      time += 0.016;
      
      if (currentMode === 'void') {
        shardMeshes.forEach(shard => {
          const data = shard.userData;
          
          if (!data.isDragging) {
            data.orbitAngle += data.orbitSpeed;
            shard.position.x = Math.cos(data.orbitAngle) * data.orbitRadius;
            shard.position.z = Math.sin(data.orbitAngle) * data.orbitRadius;
            shard.position.y = data.originalY + Math.sin(time * data.floatSpeed + data.floatOffset) * 1;
          } else if (data.originalPosition) {
            // Pull back to original position
            const pullStrength = 0.01; // Slower snap back
            shard.position.lerp(data.originalPosition, pullStrength);
          }
          
          shard.rotation.x += data.rotationSpeedX;
          shard.rotation.y += data.rotationSpeedY;
          shard.rotation.z += data.rotationSpeedZ;
          
          const targetScale = data.hovered ? 1.25 : 1;
          shard.scale.x += (targetScale - shard.scale.x) * 0.08;
          shard.scale.y += (targetScale - shard.scale.y) * 0.08;
          shard.scale.z += (targetScale - shard.scale.z) * 0.08;
        });
        
        // Animate debris shards
        debrisShards.forEach(debris => {
          const data = debris.userData;
          
          if (!data.isDragging) {
            data.orbitAngle += data.orbitSpeed;
            debris.position.x = Math.cos(data.orbitAngle) * data.orbitRadius;
            debris.position.z = Math.sin(data.orbitAngle) * data.orbitRadius;
            debris.position.y = data.originalY + Math.sin(time * data.floatSpeed + data.floatOffset) * 0.8;
          } else if (data.originalPosition) {
            // Pull back to original position - slower for debris
            const pullStrength = 0.008; // Even slower snap back for debris
            debris.position.lerp(data.originalPosition, pullStrength);
          }
          
          debris.rotation.x += data.rotationSpeedX;
          debris.rotation.y += data.rotationSpeedY;
          debris.rotation.z += data.rotationSpeedZ;
        });
        
        // Draw lines from drag connections to dragged object
        if (draggedObject && dragConnections.length > 0) {
          dragConnections.forEach((connector, index) => {
            // Create visual lines showing the pull connections
            const lineKey = `drag-line-${index}`;
            let dragLine = scene.getObjectByName(lineKey);
            
            if (!dragLine) {
              const lineGeometry = new THREE.BufferGeometry().setFromPoints([
                connector.position.clone(),
                draggedObject.position.clone()
              ]);
              const lineMaterial = new THREE.LineBasicMaterial({ 
                color: 0x000000,
                transparent: true,
                opacity: 0.6,
                linewidth: 2
              });
              dragLine = new THREE.Line(lineGeometry, lineMaterial);
              dragLine.name = lineKey;
              scene.add(dragLine);
            } else {
              // Update line positions
              const positions = dragLine.geometry.attributes.position.array;
              positions[0] = connector.position.x;
              positions[1] = connector.position.y;
              positions[2] = connector.position.z;
              positions[3] = draggedObject.position.x;
              positions[4] = draggedObject.position.y;
              positions[5] = draggedObject.position.z;
              dragLine.geometry.attributes.position.needsUpdate = true;
            }
            
            // Apply pull force
            const direction = new THREE.Vector3().subVectors(
              draggedObject.userData.originalPosition,
              draggedObject.position
            );
            const distance = direction.length();
            
            // Apply stronger pull the further it is
            if (distance > 0.1) {
              const pullForce = direction.normalize().multiplyScalar(distance * 0.03);
              draggedObject.position.add(pullForce);
            }
          });
        } else {
          // Clean up drag lines when not dragging
          for (let i = 0; i < 5; i++) {
            const lineKey = `drag-line-${i}`;
            const dragLine = scene.getObjectByName(lineKey);
            if (dragLine) {
              scene.remove(dragLine);
              dragLine.geometry.dispose();
              dragLine.material.dispose();
            }
          }
        }
        
        // Animate mist particles
        const positions = particles.geometry.attributes.position.array;
        for (let i = 1; i < positions.length; i += 3) {
          positions[i] += Math.sin(time * 0.1 + i) * 0.005;
        }
        particles.geometry.attributes.position.needsUpdate = true;
        particles.rotation.y += 0.0001;
        
        // Animate connection lines
        for (let i = lineAnimations.length - 1; i >= 0; i--) {
          const lineData = lineAnimations[i];
          const currentTime = Date.now();
          
          if (lineData.fadingOut) {
            // Fade out over 2 seconds
            const fadeProgress = (currentTime - lineData.fadeStartTime) / 2000;
            lineData.outlineMaterial.opacity = Math.max(0, 0.9 * (1 - fadeProgress));
            lineData.centerMaterial.opacity = Math.max(0, 0.9 * (1 - fadeProgress));
            
            if (fadeProgress >= 1) {
              scene.remove(lineData.outlineLine);
              scene.remove(lineData.centerLine);
              lineData.outlineGeometry.dispose();
              lineData.centerGeometry.dispose();
              lineData.outlineMaterial.dispose();
              lineData.centerMaterial.dispose();
              
              lineAnimations.splice(i, 1);
              const index = connectionLines.indexOf(lineData);
              if (index > -1) connectionLines.splice(index, 1);
            }
          } else {
            // Animate line growth - faster and smoother
            const elapsed = (currentTime - lineData.startTime) / 1000;
            const adjustedTime = Math.max(0, elapsed - lineData.delay);
            lineData.progress = Math.min(1, adjustedTime / 0.5); // 0.5 second growth per segment (faster)
            
            if (lineData.progress > 0) {
              // Get live positions
              const startPos = lineData.startDebris.position;
              const endPos = lineData.isFinalSegment ? lineData.endShard.position : lineData.endDebris.position;
              
              const currentEnd = new THREE.Vector3().lerpVectors(
                startPos,
                endPos,
                lineData.progress
              );
              
              // Update outline with live tracking
              const outlinePositions = lineData.outlineGeometry.attributes.position.array;
              outlinePositions[0] = startPos.x;
              outlinePositions[1] = startPos.y;
              outlinePositions[2] = startPos.z;
              outlinePositions[3] = currentEnd.x;
              outlinePositions[4] = currentEnd.y;
              outlinePositions[5] = currentEnd.z;
              lineData.outlineGeometry.attributes.position.needsUpdate = true;
              
              // Update center line with live tracking
              const centerPositions = lineData.centerGeometry.attributes.position.array;
              centerPositions[0] = startPos.x;
              centerPositions[1] = startPos.y;
              centerPositions[2] = startPos.z;
              centerPositions[3] = currentEnd.x;
              centerPositions[4] = currentEnd.y;
              centerPositions[5] = currentEnd.z;
              lineData.centerGeometry.attributes.position.needsUpdate = true;
            }
          }
        }
        
        // Animate glow effects and glitches
        connectionLines.forEach(lineData => {
          if (lineData.isGlow) {
            if (lineData.fadingOut) {
              const fadeProgress = (Date.now() - lineData.fadeStartTime) / 2000;
              lineData.material.opacity = Math.max(0, 0.5 * (1 - fadeProgress));
              
              if (fadeProgress >= 1) {
                scene.remove(lineData.mesh);
                lineData.material.dispose();
                const index = connectionLines.indexOf(lineData);
                if (index > -1) connectionLines.splice(index, 1);
              }
            } else {
              // Pulse the glow
              const pulse = Math.sin(time * 3) * 0.5 + 0.5;
              lineData.material.opacity = 0.3 + pulse * 0.2;
              lineData.mesh.scale.setScalar(1.5 + pulse * 0.15);
              
              // Sync position and rotation with target shard
              if (lineData.targetShard) {
                lineData.mesh.position.copy(lineData.targetShard.position);
                lineData.mesh.rotation.copy(lineData.targetShard.rotation);
                
                // Glitch effect
                lineData.glitchTimer += 0.016;
                if (lineData.glitchTimer > 0.15) {
                  lineData.glitchTimer = 0;
                  lineData.glitchActive = !lineData.glitchActive;
                }
                
                if (lineData.glitchActive) {
                  // Random offset glitch
                  lineData.targetShard.position.x += (Math.random() - 0.5) * 0.3;
                  lineData.targetShard.position.y += (Math.random() - 0.5) * 0.3;
                  lineData.targetShard.position.z += (Math.random() - 0.5) * 0.3;
                  
                  // Scale glitch
                  const glitchScale = 1 + (Math.random() - 0.5) * 0.15;
                  lineData.targetShard.scale.setScalar(glitchScale);
                }
              }
            }
          }
        });
        
      } else if (currentMode === 'project') {
        // Animate project worlds
        if (currentProjectId === 0) { // Neural AI
          projectObjects.forEach((obj, i) => {
            if (obj.geometry && obj.geometry.type === 'SphereGeometry') {
              const pulse = Math.sin(time * obj.userData.pulseSpeed + obj.userData.pulseOffset);
              obj.scale.setScalar(1 + pulse * 0.2);
              obj.material.opacity = 0.6 + pulse * 0.2;
            }
          });
        } else if (currentProjectId === 1) { // Web Dashboard
          projectObjects.forEach(panel => {
            if (panel.userData.angle !== undefined) {
              panel.userData.angle += panel.userData.rotationSpeed;
              panel.position.x = Math.cos(panel.userData.angle) * 6;
              panel.position.z = Math.sin(panel.userData.angle) * 6;
              panel.lookAt(0, 0, 0);
            }
          });
        } else if (currentProjectId === 2) { // Game Engine
          projectObjects.forEach(voxel => {
            voxel.rotation.y = time * 0.2;
          });
        } else if (currentProjectId === 3) { // Data Viz
          projectObjects.forEach(bar => {
            if (bar.userData.originalHeight) {
              const pulse = Math.sin(time * bar.userData.pulseSpeed + bar.userData.pulseOffset);
              const newHeight = bar.userData.originalHeight * (0.7 + pulse * 0.3);
              bar.scale.y = newHeight / bar.userData.originalHeight;
              bar.position.y = newHeight / 2 - 3;
              bar.material.emissiveIntensity = 0.3 + pulse * 0.3;
            }
          });
        } else if (currentProjectId === 4) { // Blockchain
          projectObjects.forEach(block => {
            if (block.userData.rotationSpeed) {
              block.rotation.x += block.userData.rotationSpeed;
              block.rotation.y += block.userData.rotationSpeed * 0.7;
              block.userData.angle += 0.001;
              block.position.x = Math.cos(block.userData.angle) * block.userData.radius;
              block.position.z = Math.sin(block.userData.angle) * block.userData.radius;
            }
          });
        }
        
        camera.lookAt(0, 0, 0);
      }
      
      renderer.render(scene, camera);
    }
    
    animate();
    
    window.addEventListener('resize', () => {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    });
  </script>
</body>
</html>