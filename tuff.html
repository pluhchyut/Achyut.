// Create debris shards (smaller pieces for depth)
    for (let i = 0; i < 25; i++) {
      const geometry = createShardGeometry();
      const material = new THREE.MeshPhysicalMaterial({
        metal<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Reflective Void Portfolio</title>
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }
    
    body {
      font-family: 'Courier New', monospace;
      background: #fff;
      overflow: hidden;
      cursor: default;
      user-select: none;
    }
    
    #canvas {
      display: block;
      width: 100vw;
      height: 100vh;
      position: fixed;
      top: 0;
      left: 0;
    }
    
    .label {
      position: absolute;
      color: black;
      font-size: 24px;
      font-weight: 100;
      letter-spacing: 4px;
      pointer-events: none;
      opacity: 0;
      transition: opacity 0.3s;
      text-shadow: 0 0 20px rgba(0,0,0,0.3);
      transform: translate(-50%, -50%);
    }
    
    .label.visible {
      opacity: 1;
    }
    
    .label-desc {
      font-size: 12px;
      opacity: 0.6;
      letter-spacing: 2px;
      margin-top: 8px;
    }
    
    .footer {
      position: absolute;
      bottom: 20px;
      left: 50%;
      transform: translateX(-50%);
      color: black;
      font-size: 10px;
      letter-spacing: 3px;
      opacity: 0.3;
    }
    
    .project-overlay {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      color: white;
      opacity: 0;
      pointer-events: none;
      transition: opacity 1s;
      z-index: 10;
      background: rgba(0, 0, 0, 0.7);
    }
    
    .project-overlay.visible {
      opacity: 1;
      pointer-events: all;
    }
    
    .fade-overlay {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: black;
      opacity: 0;
      pointer-events: none;
      transition: opacity 0.8s;
      z-index: 5;
    }
    
    .fade-overlay.active {
      opacity: 1;
    }
    
    .project-title {
      font-size: 48px;
      letter-spacing: 8px;
      margin-bottom: 16px;
      text-shadow: 0 0 30px currentColor;
    }
    
    .project-description {
      font-size: 16px;
      letter-spacing: 3px;
      opacity: 0.7;
      margin-bottom: 32px;
    }
    
    .back-button {
      padding: 12px 32px;
      border: 2px solid white;
      background: transparent;
      color: white;
      font-family: 'Courier New', monospace;
      font-size: 14px;
      letter-spacing: 3px;
      cursor: pointer;
      transition: all 0.3s;
      margin-top: 20px;
    }
    
    .back-button:hover {
      background: white;
      color: black;
      box-shadow: 0 0 20px white;
    }
  </style>
</head>
<body>
  <canvas id="canvas"></canvas>
  <div id="label" class="label">
    <div id="label-name"></div>
    <div class="label-desc" id="label-desc"></div>
  </div>
  
  <div id="project-overlay" class="project-overlay">
    <div class="project-title" id="project-title"></div>
    <div class="project-description" id="project-description"></div>
    <button class="back-button" id="back-button">← RETURN TO VOID</button>
  </div>

  <div id="intro-overlay" class="project-overlay" style="background: rgba(0,0,0,0.85); color: white;">
    <div class="project-title">REFLECTIVE VOID</div>
    <div class="project-description">click to shatter into the void</div>
    <button class="back-button" id="intro-button">ENTER THE VOID</button>
  </div>
  
  <div id="fade-overlay" class="fade-overlay"></div>
  
  <div class="footer">ACHYUT V KUMAR • PORTFOLIO 2025</div>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
  <!-- Reflector for mirror floor (falls back to physical material if unavailable) -->
  <script src="https://threejs.org/examples/js/objects/Reflector.js"></script>
  <script src="https://threejs.org/examples/js/postprocessing/EffectComposer.js"></script>
  <script src="https://threejs.org/examples/js/postprocessing/RenderPass.js"></script>
  <script src="https://threejs.org/examples/js/postprocessing/ShaderPass.js"></script>
  <script src="https://threejs.org/examples/js/shaders/CopyShader.js"></script>
  
  <script>
    // Scene setup
    const scene = new THREE.Scene();
  // darker background and smoother exponential fog for a less-harsh horizon
  scene.background = new THREE.Color(0x101018);
  // Use FogExp2 for a smoother, physically-plausible falloff
  scene.fog = new THREE.FogExp2(0x0b0b0b, 0.015);
    
  const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
  // lower the camera and tilt slightly upward so the floor reflection and horizon read better
  camera.position.set(0, 2, 20);
  camera.lookAt(0, 0, 0);
    
    const renderer = new THREE.WebGLRenderer({ 
      canvas: document.getElementById('canvas'),
      antialias: true,
      alpha: true 
    });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
  renderer.toneMapping = THREE.ACESFilmicToneMapping;
  renderer.toneMappingExposure = 1.2;
  // set clear color to a dark gray-blue to balance the mist and scene
  renderer.setClearColor(0x101018);
    
    // Projects data
    const projects = [
      { name: 'NEURAL AI', desc: 'Machine Learning Pipeline', color: 0x00ffff },
      { name: 'WEB DASHBOARD', desc: 'Real-time Analytics', color: 0xff00ff },
      { name: 'GAME ENGINE', desc: 'Voxel World Builder', color: 0xffff00 },
      { name: 'DATA VIZ', desc: 'Interactive Charts', color: 0x00ff00 },
      { name: 'BLOCKCHAIN', desc: 'Smart Contract System', color: 0xff6600 }
    ];
    
    // State management
    let currentMode = 'void';
    let currentProjectId = null;
    let projectObjects = [];
    let debrisShards = [];
    
    // Lighting - Cool blue-white key light
  // ambient fill (subtle, desaturated deep blue)
  const ambientLight = new THREE.AmbientLight(0x1a2a3f, 0.06);
  scene.add(ambientLight);

  // strong directional key light to give shards crisp specular highlights
  // make it a deep blue accent (cinematic) and keep intensity high to catch reflections
  const KEY_COLOR = 0x1133cc;
  const keyLight = new THREE.DirectionalLight(KEY_COLOR, 1.5);
  keyLight.position.set(2, 5, 3);
  scene.add(keyLight);

  // subtle rim to separate shards from background (deep blue, lower intensity)
  const rimLight = new THREE.PointLight(0x3355ff, 0.45, 30);
  rimLight.position.set(-8, 8, -8);
  scene.add(rimLight);

  // faint cool fill close to the scene for soft specular/tonal balance
  // follow requested values: intensity ~0.4, distance ~10 for controlled falloff
  const fillLight = new THREE.PointLight(0x3355ff, 0.4, 10);
  fillLight.position.set(0, 1, 0);
  scene.add(fillLight);

  // soft proximity pulse light to subtly 'charge' the fog near shards
  // Use the same deep-blue hue but keep intensity low and distance modest
  const fogPulseLight = new THREE.PointLight(0x3355ff, 0.0, 18, 2);
  fogPulseLight.intensity = 0.0;
  fogPulseLight.distance = 18;
  fogPulseLight.decay = 2.0;
  scene.add(fogPulseLight);
    
    // Obsidian mirror floor: prefer Reflector (real reflection). Fall back to a
    // high-metalness MeshPhysicalMaterial if Reflector isn't available.
    const floorGeometry = new THREE.PlaneGeometry(200, 200);
    let floor;
    if (THREE.Reflector) {
      floor = new THREE.Reflector(floorGeometry, {
        clipBias: 0.003,
        textureWidth: Math.floor(window.innerWidth * renderer.getPixelRatio()),
        textureHeight: Math.floor(window.innerHeight * renderer.getPixelRatio()),
        color: 0x060606
      });
      floor.rotation.x = -Math.PI / 2;
      floor.position.y = -5;
      scene.add(floor);
    } else {
      // fallback - still quite reflective
      const floorMaterial = new THREE.MeshPhysicalMaterial({
        color: 0x060606,
        metalness: 0.95,
        roughness: 0.18,
        clearcoat: 1,
        clearcoatRoughness: 0.05,
        reflectivity: 1,
        envMapIntensity: 0.8
      });
      floor = new THREE.Mesh(floorGeometry, floorMaterial);
      floor.rotation.x = -Math.PI / 2;
      floor.position.y = -5;
      scene.add(floor);
    }

    // Ripple overlay plane sits just above the floor and uses a small shader to
    // perturb color/alpha to give the illusion of slow-moving ripples on the
    // obsidian mirror surface. This avoids modifying the Reflector internals.
    const rippleUniforms = {
      uTime: { value: 0 },
      uColor: { value: new THREE.Color(0x000000) },
      uAmplitude: { value: 0.08 },
      uScale: { value: 3.5 },
      uOpacity: { value: 0.12 }
    };

    const rippleMaterial = new THREE.ShaderMaterial({
      uniforms: rippleUniforms,
      vertexShader: `
        varying vec2 vUv;
        void main() {
          vUv = uv;
          gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
        }
      `,
      fragmentShader: `
        uniform float uTime;
        uniform float uAmplitude;
        uniform float uScale;
        uniform float uOpacity;
        uniform vec3 uColor;
        varying vec2 vUv;

        // Simple layered sin-based ripples (cheap pseudo-noise)
        float ripple(vec2 p) {
          float t = uTime * 0.12;
          float r = 0.0;
          r += sin((p.x + p.y * 0.7) * uScale + t) * 0.5;
          r += sin((p.x * 0.6 - p.y * 1.2) * (uScale * 0.6) - t * 0.7) * 0.35;
          r += sin((p.x * 1.7 + p.y * 0.4) * (uScale * 0.4) + t * 1.3) * 0.25;
          return r * 0.5;
        }

        void main() {
          vec2 p = vUv * 2.0 - 1.0;
          float r = ripple(p);
          float shade = smoothstep(-0.2, 0.6, r * uAmplitude);
          vec3 base = vec3(0.02, 0.02, 0.035);
          vec3 col = mix(base, uColor * 0.25, shade);
          gl_FragColor = vec4(col, uOpacity * (0.5 + shade * 0.5));
        }
      `,
      transparent: true,
      depthWrite: false
    });

    const ripplePlane = new THREE.Mesh(new THREE.PlaneGeometry(200, 200, 1, 1), rippleMaterial);
    ripplePlane.rotation.x = -Math.PI / 2;
    ripplePlane.position.y = -4.99; // slightly above the floor to prevent z-fighting
    ripplePlane.renderOrder = 2;
    scene.add(ripplePlane);
    
    // Mist particles
    const particleCount = 800;
    const particleGeometry = new THREE.BufferGeometry();
    const positions = new Float32Array(particleCount * 3);
    
    for (let i = 0; i < particleCount * 3; i += 3) {
      positions[i] = (Math.random() - 0.5) * 100;
      positions[i + 1] = Math.random() * 40 - 5;
      positions[i + 2] = (Math.random() - 0.5) * 100;
    }
    
    particleGeometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
    
    const particleMaterial = new THREE.PointsMaterial({
      color: 0x6699bb,
      size: 0.08,
      opacity: 0.12,
      transparent: true,
      depthWrite: false,
      blending: THREE.AdditiveBlending
    });
    
    const particles = new THREE.Points(particleGeometry, particleMaterial);
    scene.add(particles);
    
    // Function to create irregular glass shard geometry
    function createShardGeometry() {
      const geometry = new THREE.BufferGeometry();
      const vertices = [];
      
      const points = 5 + Math.floor(Math.random() * 4);
      const baseSize = 1.5 + Math.random() * 2;
      
      const centerX = 0;
      const centerY = 0;
      
      const angleStep = (Math.PI * 2) / points;
      const shardPoints = [];
      
      for (let i = 0; i < points; i++) {
        const angle = angleStep * i + (Math.random() - 0.5) * 0.5;
        const radius = baseSize * (0.4 + Math.random() * 0.6);
        shardPoints.push({
          x: Math.cos(angle) * radius,
          y: Math.sin(angle) * radius
        });
      }
      
      for (let i = 0; i < points; i++) {
        const p1 = shardPoints[i];
        const p2 = shardPoints[(i + 1) % points];
        
        vertices.push(centerX, centerY, 0);
        vertices.push(p1.x, p1.y, 0);
        vertices.push(p2.x, p2.y, 0);
        
        vertices.push(centerX, centerY, 0);
        vertices.push(p2.x, p2.y, 0);
        vertices.push(p1.x, p1.y, 0);
      }
      
      geometry.setAttribute('position', new THREE.Float32BufferAttribute(vertices, 3));
      geometry.computeVertexNormals();
      
      return geometry;
    }
    
    // Create 5 glass shards with enhanced material
    const shards = [];
    const shardMeshes = [];
    
    for (let i = 0; i < 5; i++) {
      const geometry = createShardGeometry();
      
      const material = new THREE.MeshPhysicalMaterial({
        metalness: 1.0,
        roughness: 0.03,
        transmission: 0.0,
        // thickness removed for opaque reflective shards
        reflectivity: 1,
        clearcoat: 1.0,
        clearcoatRoughness: 0.1,
        color: 0x010101, // near-black base so reflections pop
        emissive: 0x000000,
        emissiveIntensity: 0,
        transparent: true,
        opacity: 0.95,
        side: THREE.DoubleSide,
        envMapIntensity: 2.2
      });
      
      const shard = new THREE.Mesh(geometry, material);
      
      const angle = (i / 5) * Math.PI * 2;
      const radius = 12;
  // compute and store the final (target) position, then start shard at center for the intro
  const finalX = Math.cos(angle) * radius;
  const finalY = (Math.random() - 0.5) * 4;
  const finalZ = Math.sin(angle) * radius;
  shard.userData.targetPosition = new THREE.Vector3(finalX, finalY, finalZ);
  // start at center (will animate out on intro)
  shard.position.set(0, 0, 0);
      
      shard.rotation.x = Math.random() * Math.PI * 2;
      shard.rotation.y = Math.random() * Math.PI * 2;
      shard.rotation.z = Math.random() * Math.PI * 2;
      
      shard.userData = {
        projectId: i,
        orbitSpeed: 0.0002 + Math.random() * 0.0003,
        orbitAngle: angle,
        orbitRadius: radius,
        floatSpeed: 0.0005 + Math.random() * 0.0008,
        floatOffset: Math.random() * Math.PI * 2,
        rotationSpeedX: (Math.random() - 0.5) * 0.001,
        rotationSpeedY: (Math.random() - 0.5) * 0.0007,
        rotationSpeedZ: (Math.random() - 0.5) * 0.0005,
        originalY: shard.position.y,
        // intro shatter control
        shatterStart: 0,
        shatterDuration: 800 + Math.round(Math.random() * 300),
        shattering: false,
        hovered: false
      };
      
      // start them very small so the shatter anim grows them
      shard.scale.setScalar(0.001);
      scene.add(shard);
      shardMeshes.push(shard);
      shards.push({
        mesh: shard,
        project: projects[i]
      });
    }
    
    // Create debris shards (smaller pieces for depth)
    for (let i = 0; i < 25; i++) {
      const geometry = createShardGeometry();
    const material = new THREE.MeshPhysicalMaterial({
      metalness: 1.0,
      // slightly smoother debris so it still reads reflections in low light
      roughness: 0.04,
      transmission: 0.0,
      reflectivity: 1,
      clearcoat: 1.0,
      clearcoatRoughness: 0.12,
      color: 0x020202,
      emissive: 0x000000,
      emissiveIntensity: 0,
      transparent: true,
      opacity: 0.92,
      side: THREE.DoubleSide,
      envMapIntensity: 1.95
    });
      
      const debris = new THREE.Mesh(geometry, material);
        // compute final target then start at origin small
  debris.scale.setScalar(0.001);
  const angle = (i / 25) * Math.PI * 2;
  const radius = 6 + Math.random() * 10;
  const finalX = Math.cos(angle) * radius;
  const finalY = Math.max(-4, (Math.random() - 0.5) * 12); // Prevent spawning below floor
  const finalZ = Math.sin(angle) * radius;
  debris.userData.targetPosition = new THREE.Vector3(finalX, finalY, finalZ);
  debris.position.set(0, 0, 0);
      
      debris.rotation.x = Math.random() * Math.PI * 2;
      debris.rotation.y = Math.random() * Math.PI * 2;
      debris.rotation.z = Math.random() * Math.PI * 2;
      
      debris.userData = {
        orbitSpeed: 0.0001 + Math.random() * 0.0003,
        orbitAngle: angle,
        orbitRadius: radius,
        floatSpeed: 0.0008 + Math.random() * 0.0015,
        floatOffset: Math.random() * Math.PI * 2,
        rotationSpeedX: (Math.random() - 0.5) * 0.002,
        rotationSpeedY: (Math.random() - 0.5) * 0.002,
        rotationSpeedZ: (Math.random() - 0.5) * 0.0015,
        originalY: debris.position.y,
        shatterStart: 0,
        shatterDuration: 600 + Math.round(Math.random() * 300),
        shattering: false
      };
      
      scene.add(debris);
      debrisShards.push(debris);
    }

      // Remove any drag-line groups (we no longer show lines while dragging)
      for (let i = 0; i < 5; i++) {
        const lineKey = `drag-line-${i}`;
        const dragGroup = scene.getObjectByName(lineKey);
        if (dragGroup) {
          const disposeRec = (obj) => {
            if (obj.children) obj.children.forEach(c => disposeRec(c));
            if (obj.geometry) obj.geometry.dispose();
            if (obj.material) {
              if (Array.isArray(obj.material)) obj.material.forEach(m => m.dispose());
              else obj.material.dispose();
            }
          };
          disposeRec(dragGroup);
          scene.remove(dragGroup);
        }
      }

      // Autoglide pieces that were dragged away: smoothly lerp them back to original position
      const nowAuto2 = Date.now();
      const easeOutCubic = (t) => (--t) * t * t + 1;
      shardMeshes.forEach(shard => {
        const d = shard.userData;
        if (d && d.autoglide) {
          const t0 = d.autoglideStart || nowAuto2;
          const dur = d.autoglideDuration || 600;
          const prog = Math.min(1, (nowAuto2 - t0) / dur);
          const eased = easeOutCubic(prog);
          if (d.autoglideFrom && d.autoglideTo) {
            shard.position.lerpVectors(d.autoglideFrom, d.autoglideTo, eased);
          }
          shard.scale.setScalar(THREE.MathUtils.lerp(0.001, d._finalScale || 1, eased));
          if (prog >= 1) {
            d.autoglide = false;
            d.wasDragged = false;
            if (d.originalPosition) shard.position.copy(d.originalPosition);
          }
        }
      });

      debrisShards.forEach(debris => {
        const d = debris.userData;
        if (d && d.autoglide) {
          const t0 = d.autoglideStart || nowAuto2;
          const dur = d.autoglideDuration || 600;
          const prog = Math.min(1, (nowAuto2 - t0) / dur);
          const eased = easeOutCubic(prog);
          if (d.autoglideFrom && d.autoglideTo) {
            debris.position.lerpVectors(d.autoglideFrom, d.autoglideTo, eased);
          }
          debris.scale.setScalar(THREE.MathUtils.lerp(0.001, d._finalScale || 0.25, eased));
          if (prog >= 1) {
            d.autoglide = false;
            d.wasDragged = false;
            if (d.originalPosition) debris.position.copy(d.originalPosition);
          }
        }
      });

    // Helper: create an anchored cylinder that grows from startVec toward endVec.
    // Implementation uses a parent Object3D placed at `startVec` and a unit-height cylinder
    // whose geometry is translated so its base is at y=0. Scaling the child in Y grows the cylinder
    // outward from the start point. Returns the parent Object3D (parent.children[0] is the mesh).
    function createConnectorCylinder(startVec, endVec, radius, material) {
      const dir = new THREE.Vector3().subVectors(endVec, startVec);
      const length = Math.max(dir.length(), 0.0001);

      // create a unit cylinder (height = 1) and translate so base is at y=0
      const geometry = new THREE.CylinderGeometry(radius, radius, 1, 8, 1, true);
      geometry.translate(0, 0.5, 0); // move geometry so base is at origin

      const mesh = new THREE.Mesh(geometry, material);

      // parent to allow anchoring at the start position and orientation
      const parent = new THREE.Object3D();
      parent.position.copy(startVec);

      // orient parent so its local +Y points toward the direction
      const quat = new THREE.Quaternion().setFromUnitVectors(new THREE.Vector3(0, 1, 0), dir.clone().normalize());
      parent.quaternion.copy(quat);

      // set initial scale to almost zero (so it can grow)
      mesh.scale.set(1, 0.001, 1);

      parent.add(mesh);

      // store metadata for animated growth
      parent.userData = {
        start: startVec.clone(),
        end: endVec.clone(),
        targetLength: length,
        growStartTime: Date.now(),
        growDuration: 400 // ms
      };

      return parent;
    }
    
    // Project world creators
    function createNeuralAIWorld() {
      const objects = [];
      const color = 0x00ffff;
      
      const nodeGeometry = new THREE.SphereGeometry(0.3, 16, 16);
      const nodeMaterial = new THREE.MeshBasicMaterial({ 
        color: color,
        transparent: true,
        opacity: 0.8
      });
      
      for (let layer = 0; layer < 4; layer++) {
        const nodesInLayer = 3 + layer;
        for (let i = 0; i < nodesInLayer; i++) {
          const node = new THREE.Mesh(nodeGeometry, nodeMaterial.clone());
          node.position.x = (i - nodesInLayer / 2) * 3;
          node.position.y = (Math.random() - 0.5) * 2;
          node.position.z = (layer - 1.5) * 5;
          node.userData = { 
            pulseSpeed: 1 + Math.random() * 2,
            pulseOffset: Math.random() * Math.PI * 2
          };
          scene.add(node);
          objects.push(node);
        }
      }
      
      const lineMaterial = new THREE.LineBasicMaterial({ 
        color: color,
        transparent: true,
        opacity: 0.3
      });
      
      for (let i = 0; i < 30; i++) {
        const points = [];
        const obj1 = objects[Math.floor(Math.random() * objects.length)];
        const obj2 = objects[Math.floor(Math.random() * objects.length)];
        points.push(obj1.position);
        points.push(obj2.position);
        const lineGeometry = new THREE.BufferGeometry().setFromPoints(points);
        const line = new THREE.Line(lineGeometry, lineMaterial);
        scene.add(line);
        objects.push(line);
      }
      
      return objects;
    }
    
    function createWebDashboardWorld() {
      const objects = [];
      const color = 0xff00ff;
      
      for (let i = 0; i < 8; i++) {
        const width = 2 + Math.random() * 2;
        const height = 1.5 + Math.random() * 1.5;
        const panelGeometry = new THREE.PlaneGeometry(width, height);
        const panelMaterial = new THREE.MeshBasicMaterial({
          color: color,
          transparent: true,
          opacity: 0.2,
          side: THREE.DoubleSide
        });
        
        const panel = new THREE.Mesh(panelGeometry, panelMaterial);
        const angle = (i / 8) * Math.PI * 2;
        panel.position.x = Math.cos(angle) * 6;
        panel.position.y = (Math.random() - 0.5) * 4;
        panel.position.z = Math.sin(angle) * 6;
        panel.lookAt(0, 0, 0);
        
        const edgeGeometry = new THREE.EdgesGeometry(panelGeometry);
        const edgeMaterial = new THREE.LineBasicMaterial({ color: color });
        const edges = new THREE.LineSegments(edgeGeometry, edgeMaterial);
        panel.add(edges);
        
        panel.userData = { 
          rotationSpeed: 0.005 + Math.random() * 0.01,
          angle: angle
        };
        
        scene.add(panel);
        objects.push(panel);
      }
      
      return objects;
    }
    
    function createGameEngineWorld() {
      const objects = [];
      const color = 0xffff00;
      
      const voxelSize = 0.8;
      const gridSize = 12;
      
      for (let x = -gridSize/2; x < gridSize/2; x++) {
        for (let z = -gridSize/2; z < gridSize/2; z++) {
          const height = Math.floor(Math.random() * 3) + 1;
          for (let y = 0; y < height; y++) {
            const voxelGeometry = new THREE.BoxGeometry(voxelSize, voxelSize, voxelSize);
            const voxelMaterial = new THREE.MeshPhongMaterial({
              color: color,
              transparent: true,
              opacity: 0.7,
              emissive: color,
              emissiveIntensity: 0.2
            });
            
            const voxel = new THREE.Mesh(voxelGeometry, voxelMaterial);
            voxel.position.set(x * voxelSize, y * voxelSize - 5, z * voxelSize);
            
            scene.add(voxel);
            objects.push(voxel);
          }
        }
      }
      
      return objects;
    }
    
    function createDataVizWorld() {
      const objects = [];
      const color = 0x00ff00;
      
      const gridSize = 20;
      const spacing = 1;
      
      for (let x = -gridSize/2; x < gridSize/2; x++) {
        for (let z = -gridSize/2; z < gridSize/2; z++) {
          const barHeight = 0.5 + Math.random() * 3;
          const barGeometry = new THREE.BoxGeometry(0.3, barHeight, 0.3);
          const barMaterial = new THREE.MeshPhongMaterial({
            color: color,
            emissive: color,
            emissiveIntensity: 0.5,
            transparent: true,
            opacity: 0.8
          });
          
          const bar = new THREE.Mesh(barGeometry, barMaterial);
          bar.position.set(x * spacing, barHeight / 2 - 3, z * spacing);
          bar.userData = { 
            originalHeight: barHeight,
            pulseSpeed: 0.5 + Math.random() * 1,
            pulseOffset: Math.random() * Math.PI * 2
          };
          
          scene.add(bar);
          objects.push(bar);
        }
      }
      
      return objects;
    }
    
    function createBlockchainWorld() {
      const objects = [];
      const color = 0xff6600;
      
      const blockCount = 12;
      
      for (let i = 0; i < blockCount; i++) {
        const blockGeometry = new THREE.BoxGeometry(1.5, 1.5, 1.5);
        const blockMaterial = new THREE.MeshPhongMaterial({
          color: color,
          emissive: color,
          emissiveIntensity: 0.3,
          transparent: true,
          opacity: 0.7
        });
        
        const block = new THREE.Mesh(blockGeometry, blockMaterial);
        const angle = (i / blockCount) * Math.PI * 2;
        const radius = 8;
        block.position.x = Math.cos(angle) * radius;
        block.position.y = Math.sin(i * 0.5) * 2;
        block.position.z = Math.sin(angle) * radius;
        
        block.rotation.x = Math.random() * Math.PI;
        block.rotation.y = Math.random() * Math.PI;
        
        block.userData = {
          rotationSpeed: 0.01,
          angle: angle,
          radius: radius
        };
        
        const wireframeGeometry = new THREE.EdgesGeometry(blockGeometry);
        const wireframeMaterial = new THREE.LineBasicMaterial({ color: 0xffffff });
        const wireframe = new THREE.LineSegments(wireframeGeometry, wireframeMaterial);
        block.add(wireframe);
        
        scene.add(block);
        objects.push(block);
      }
      
      return objects;
    }
    
    function enterProjectWorld(projectId) {
      const fadeOverlay = document.getElementById('fade-overlay');
      
      fadeOverlay.classList.add('active');
      
      setTimeout(() => {
        currentMode = 'project';
        currentProjectId = projectId;
        
        shardMeshes.forEach(shard => {
          shard.visible = false;
        });
        
        debrisShards.forEach(debris => {
          debris.visible = false;
        });
        
        switch(projectId) {
          case 0:
            projectObjects = createNeuralAIWorld();
            scene.fog.color.setHex(0x081025);
            break;
          case 1:
            projectObjects = createWebDashboardWorld();
            scene.fog.color.setHex(0x081025);
            break;
          case 2:
            projectObjects = createGameEngineWorld();
            scene.fog.color.setHex(0x081025);
            break;
          case 3:
            projectObjects = createDataVizWorld();
            scene.fog.color.setHex(0x081025);
            break;
          case 4:
            projectObjects = createBlockchainWorld();
            scene.fog.color.setHex(0x081025);
            break;
        }
        
        const overlay = document.getElementById('project-overlay');
        const title = document.getElementById('project-title');
        const description = document.getElementById('project-description');
        
        title.textContent = projects[projectId].name;
        title.style.color = '#' + projects[projectId].color.toString(16).padStart(6, '0');
        description.textContent = projects[projectId].desc;
        overlay.classList.add('visible');
        
        camera.position.z = 15;
        // Keep the global fog color cinematic and deep-blue even inside project overlays.
        // Project objects can use colored materials, but the ambient haze should remain
        // the BASE_FOG_COLOR to avoid harsh color contamination.
        if (typeof BASE_FOG_COLOR !== 'undefined') {
          scene.fog.color.copy(BASE_FOG_COLOR);
        } else {
          scene.fog.color.setHex(0x0b0b0b);
        }
        
        setTimeout(() => {
          fadeOverlay.classList.remove('active');
        }, 100);
      }, 800);
    }
    
    function exitProjectWorld() {
      const fadeOverlay = document.getElementById('fade-overlay');
      const overlay = document.getElementById('project-overlay');
      
      overlay.classList.remove('visible');
      
      fadeOverlay.classList.add('active');
      
      setTimeout(() => {
        currentMode = 'void';
        
        projectObjects.forEach(obj => {
          scene.remove(obj);
          if (obj.geometry) obj.geometry.dispose();
          if (obj.material) {
            if (Array.isArray(obj.material)) {
              obj.material.forEach(mat => mat.dispose());
            } else {
              obj.material.dispose();
            }
          }
        });
        projectObjects = [];
        
        shardMeshes.forEach(shard => {
          shard.visible = true;
          shard.material.emissive.setHex(0x000000);
          shard.material.emissiveIntensity = 0;
        });
        
        debrisShards.forEach(debris => {
          debris.visible = true;
        });
        
  // restore base fog color for cinematic look
  if (typeof BASE_FOG_COLOR !== 'undefined') scene.fog.color.copy(BASE_FOG_COLOR);
  else scene.fog.color.setHex(0x0b0b0b);
        
        // Reset camera to initial spherical position
        cameraRotation.theta = 0;
        cameraRotation.phi = Math.PI / 8;
        cameraDistance = 25;
        updateCameraPosition();
        
        currentProjectId = null;
        
        setTimeout(() => {
          fadeOverlay.classList.remove('active');
        }, 100);
      }, 800);
    }
    
    // Mouse interaction and camera controls
    const mouse = new THREE.Vector2();
    const raycaster = new THREE.Raycaster();
    let hoveredShard = null;
    let hoveredDebris = null;
    let connectionLines = [];
    let lineAnimations = [];
    let draggedObject = null;
    let dragPlane = new THREE.Plane(new THREE.Vector3(0, 1, 0), 0);
    let dragOffset = new THREE.Vector3();
    let dragConnections = [];
    
    const label = document.getElementById('label');
    const labelName = document.getElementById('label-name');
    const labelDesc = document.getElementById('label-desc');
    const introOverlay = document.getElementById('intro-overlay');
    const introButton = document.getElementById('intro-button');
    // show the intro overlay at startup
    if (introOverlay) introOverlay.classList.add('visible');

    let introComplete = false;

  // Intro / explosion tuning
  const INTRO_AUTO_START_MS = 1400; // auto-start intro after this ms (0 to disable)
  const EXPLOSION_FORCE = 18.0; // base impulse magnitude
  const GRAVITY = 18.0; // units/sec^2 downward
  const DAMPING = 0.92; // per-frame damping (0..1)
  const PARTICLE_COUNT = 140;
  const PARTICLE_LIFETIME = 1200; // ms

  let introParticles = null; // particle burst data

// dynamic fog/pulse helpers
const MAX_FOG_PULSE_DISTANCE = 28; // how far shards influence fog (increased)
const BASE_FOG_COLOR = new THREE.Color(0x0b0b0b);
const fogBlendColor = new THREE.Color(0x0066ff);


    function startIntroShatter() {
      if (introOverlay) introOverlay.classList.remove('visible');
      const now = Date.now();
      const shardStagger = 80;
      const debrisStagger = 25;

      // schedule shards
      shardMeshes.forEach((sh, idx) => {
        sh.userData.shatterStart = now + idx * shardStagger;
        sh.userData.shattering = true;
        // ensure they start at origin (we initialized them at origin)
      });

      // schedule debris to follow shards
      debrisShards.forEach((d, idx) => {
        d.userData.shatterStart = now + shardMeshes.length * shardStagger + idx * debrisStagger;
        d.userData.shattering = true;
      });

      // create a short particle burst at origin
      const particleGeom = new THREE.BufferGeometry();
      const positions = new Float32Array(PARTICLE_COUNT * 3);
      const alphas = new Float32Array(PARTICLE_COUNT);
      const velocities = new Float32Array(PARTICLE_COUNT * 3);
      for (let i = 0; i < PARTICLE_COUNT; i++) {
        positions[i * 3] = 0;
        positions[i * 3 + 1] = 0;
        positions[i * 3 + 2] = 0;
        alphas[i] = 1.0;

        // random outward velocity
        const theta = Math.random() * Math.PI * 2;
        const phi = Math.acos(2 * Math.random() - 1);
        const r = 6 + Math.random() * 6;
        velocities[i * 3] = Math.sin(phi) * Math.cos(theta) * r;
        velocities[i * 3 + 1] = Math.cos(phi) * r * 0.8 + 4;
        velocities[i * 3 + 2] = Math.sin(phi) * Math.sin(theta) * r;
      }
      particleGeom.setAttribute('position', new THREE.BufferAttribute(positions, 3));
      particleGeom.setAttribute('alpha', new THREE.BufferAttribute(alphas, 1));
      const particleMat = new THREE.PointsMaterial({ color: 0xffffff, size: 0.08, transparent: true, opacity: 1, depthWrite: false, blending: THREE.AdditiveBlending });
      const particlePoints = new THREE.Points(particleGeom, particleMat);
      scene.add(particlePoints);
      introParticles = { mesh: particlePoints, velocities: velocities, startTime: now, life: PARTICLE_LIFETIME };

      // assign initial velocities to shards/debris at their start time (computed in animation)
    }

    if (introButton) {
      introButton.addEventListener('click', () => startIntroShatter());
    }
    // Optionally auto-start the intro after a short timeout
    if (INTRO_AUTO_START_MS && INTRO_AUTO_START_MS > 0) {
      setTimeout(() => startIntroShatter(), INTRO_AUTO_START_MS);
    }
    
    // Function to find nearest shard to a position
    function findNearestShard(position, shardArray) {
      let nearest = null;
      let minDistance = Infinity;
      
      shardArray.forEach(shard => {
        const distance = position.distanceTo(shard.position);
        if (distance < minDistance) {
          minDistance = distance;
          nearest = shard;
        }
      });
      
      return nearest;
    }
    
    // Function to create connection lines
    function createConnectionLines() {
      // Mark existing lines for fade out
      connectionLines.forEach(lineData => {
        if (!lineData.fadingOut) {
          lineData.fadingOut = true;
          lineData.fadeStartTime = Date.now();
        }
      });
      
      if (!hoveredDebris) return;
      
      // Create chained connections from debris to debris to main shard
      let currentDebris = hoveredDebris;
      const processedDebris = new Set([hoveredDebris]);
      
      const waypoints = [hoveredDebris];
      let targetShard = null;
      
      // Build the path
      for (let i = 0; i < 5; i++) {
        const nearestShard = findNearestShard(currentDebris.position, shardMeshes);
        const nearestDebris = findNearestShard(
          currentDebris.position, 
          debrisShards.filter(d => !processedDebris.has(d))
        );
        
        const distToShard = currentDebris.position.distanceTo(nearestShard.position);
        const distToDebris = nearestDebris ? currentDebris.position.distanceTo(nearestDebris.position) : Infinity;
        
        if (distToShard < distToDebris || !nearestDebris) {
          waypoints.push(nearestShard);
          targetShard = nearestShard;
          break;
        } else {
          waypoints.push(nearestDebris);
          processedDebris.add(nearestDebris);
          currentDebris = nearestDebris;
        }
      }
      
      // Create dots at each waypoint (except the last one which is the shard).
      // Each dot is rendered as a black outline sphere behind a smaller white center sphere.
      waypoints.forEach((waypoint, index) => {
        if (index < waypoints.length - 1) { // Don't add dot to final shard
          const dotGeometry = new THREE.SphereGeometry(0.15, 8, 8);
          // outline (slightly larger, black)
          const outlineGeometry = new THREE.SphereGeometry(0.18, 8, 8);
          const outlineMat = new THREE.MeshBasicMaterial({ color: 0x000000, transparent: true, opacity: 0.9 });
          const centerMat = new THREE.MeshBasicMaterial({ color: 0xffffff, transparent: true, opacity: 1 });

          const outlineDot = new THREE.Mesh(outlineGeometry, outlineMat);
          const centerDot = new THREE.Mesh(dotGeometry, centerMat);

          outlineDot.position.copy(waypoint.position);
          centerDot.position.copy(waypoint.position);

          scene.add(outlineDot);
          scene.add(centerDot);

          connectionLines.push({ isDot: true, mesh: outlineDot, material: outlineMat, waypoint: waypoint, waypointIndex: index, fadingOut: false, fadeStartTime: 0 });
          connectionLines.push({ isDot: true, mesh: centerDot, material: centerMat, waypoint: waypoint, waypointIndex: index, fadingOut: false, fadeStartTime: 0 });
        }
      });
      
      // Create lines connecting all dots as a chained sequence of thin white cylinders.
      // Instead of instantly spawning independent cylinders, we stagger their growStartTime
      // so they animate out from the first waypoint like a single chain.
      // Start the first segment immediately; subsequent segments begin when the previous finishes.
      // Use a constant speed (units per second) so time = distance / speed.
      const SPEED_UNITS_PER_SEC = 6.5; // higher => faster (tweak this value to taste)
      const MIN_GROW_MS = 80; // clamp min duration per segment
      const OVERLAP_FACTOR = 0.22; // fraction of duration to overlap (0..1). >0 for smoother seamless look

      let cumulativeStart = Date.now();
      for (let i = 0; i < waypoints.length - 1; i++) {
        const startWaypoint = waypoints[i];
        const endWaypoint = waypoints[i + 1];

        const startPos = startWaypoint.position.clone();
        const endPos = endWaypoint.position.clone();

        // outline as a thin white cylinder (no separate center line)
        const outlineMatMesh = new THREE.MeshBasicMaterial({ color: 0xffffff, transparent: true, opacity: 0.95 });
        const outlineGroup = createConnectorCylinder(startPos, endPos, 0.03, outlineMatMesh); // thinner radius

  // compute segment-specific grow duration using constant speed
  const segLen = startPos.distanceTo(endPos);
  const growDur = Math.max(MIN_GROW_MS, Math.round((segLen / SPEED_UNITS_PER_SEC) * 1000));

  // schedule this segment to start after previous segments finish, but allow overlap for visual smoothness
  outlineGroup.userData.growStartTime = cumulativeStart;
  outlineGroup.userData.growDuration = growDur;
  // next segment should start slightly before this one finishes to hide seams
  cumulativeStart += Math.round(growDur * (1 - OVERLAP_FACTOR));

        scene.add(outlineGroup);

        connectionLines.push({
          isDotLine: true,
          mesh: outlineGroup,
          geometry: outlineGroup.children[0].geometry,
          material: outlineMatMesh,
          startWaypoint: startWaypoint,
          endWaypoint: endWaypoint,
          fadingOut: false,
          fadeStartTime: 0,
          growStartTime: outlineGroup.userData.growStartTime,
          growDuration: outlineGroup.userData.growDuration
        });
      }
      
      // Create glow for target shard with white outline
      if (targetShard) {
         focusPoint = hoveredShard.position.clone();
          focusColor.setHex(KEY_COLOR);
        };
        const glowMesh = new THREE.Mesh(glowGeometry, glowMaterial);
        glowMesh.position.copy(targetShard.position);
        glowMesh.rotation.copy(targetShard.rotation);
        glowMesh.scale.copy(targetShard.scale).multiplyScalar(1.5);
        scene.add(glowMesh);
        
        connectionLines.push({
          isGlow: true,
          mesh: glowMesh,
          material: glowMaterial,
          targetShard: targetShard,
          originalPosition: targetShard.position.clone(),
          originalScale: targetShard.scale.clone(),
          fadingOut: false,
          fadeStartTime: 0
        });
      }
      
      // (Removed legacy continuous Line/centerLine approach — we're using staggered
      // cylinder segments above to form a single visual chain.)
    
    
    // Camera control variables
    let isDragging = false;
    let previousMousePosition = { x: 0, y: 0 };
  let cameraRotation = { theta: 0, phi: Math.PI / 10 }; // theta: horizontal, phi: vertical (tilt slightly upward)
    let cameraDistance = 25;
    const MIN_DISTANCE = 8;
    const MAX_DISTANCE = 50;
    const MIN_PHI = 0.1; // Prevent going below ground (90 degrees from flat)
    const MAX_PHI = Math.PI / 2 - 0.1; // Limit upward angle
    
    function updateCameraPosition() {
      camera.position.x = cameraDistance * Math.sin(cameraRotation.phi) * Math.cos(cameraRotation.theta);
      camera.position.y = cameraDistance * Math.cos(cameraRotation.phi);
      camera.position.z = cameraDistance * Math.sin(cameraRotation.phi) * Math.sin(cameraRotation.theta);
      camera.lookAt(0, 0, 0);
    }
    
    window.addEventListener('mousedown', (event) => {
      if (currentMode === 'void') {
        if (!introComplete) return; // block interactions until intro finishes
        raycaster.setFromCamera(mouse, camera);
        
        // Check if clicking on a shard or debris
        const shardIntersects = raycaster.intersectObjects(shardMeshes);
        const debrisIntersects = raycaster.intersectObjects(debrisShards);
        
        if (shardIntersects.length > 0) {
          draggedObject = shardIntersects[0].object;
          draggedObject.userData.isDragging = true;
          draggedObject.userData.originalPosition = draggedObject.position.clone();
          
          // Find 3-5 random debris pieces to pull it back
          const numConnections = 3 + Math.floor(Math.random() * 3);
          dragConnections = [];
          
          const shuffledDebris = [...debrisShards].sort(() => Math.random() - 0.5);
          for (let i = 0; i < Math.min(numConnections, shuffledDebris.length); i++) {
            dragConnections.push(shuffledDebris[i]);
          }
          
          // Calculate intersection with drag plane
          dragPlane.setFromNormalAndCoplanarPoint(
            camera.getWorldDirection(dragPlane.normal),
            draggedObject.position
          );
          
          const intersection = new THREE.Vector3();
          raycaster.ray.intersectPlane(dragPlane, intersection);
          dragOffset.copy(draggedObject.position).sub(intersection);
          
          label.classList.remove('visible');
          event.preventDefault();
        } else if (debrisIntersects.length > 0) {
          draggedObject = debrisIntersects[0].object;
          draggedObject.userData.isDragging = true;
          draggedObject.userData.originalPosition = draggedObject.position.clone();
          
          // Find 3-5 random debris pieces to pull it back
          const numConnections = 3 + Math.floor(Math.random() * 3);
          dragConnections = [];
          
          const shuffledDebris = [...debrisShards].filter(d => d !== draggedObject).sort(() => Math.random() - 0.5);
          for (let i = 0; i < Math.min(numConnections, shuffledDebris.length); i++) {
            dragConnections.push(shuffledDebris[i]);
          }
          
          // Calculate intersection with drag plane
          dragPlane.setFromNormalAndCoplanarPoint(
            camera.getWorldDirection(dragPlane.normal),
            draggedObject.position
          );
          
          const intersection = new THREE.Vector3();
          raycaster.ray.intersectPlane(dragPlane, intersection);
          dragOffset.copy(draggedObject.position).sub(intersection);
          
          event.preventDefault();
        } else {
          isDragging = true;
          previousMousePosition = { x: event.clientX, y: event.clientY };
          document.body.style.cursor = 'grabbing';
        }
      }
    });
    
    window.addEventListener('mouseup', () => {
      if (draggedObject) {
        // mark as 'wasDragged' if it was moved significantly from its original position
        const orig = draggedObject.userData.originalPosition;
        if (orig) {
          const movedDist = draggedObject.position.distanceTo(orig);
          // threshold in world units — tune as desired
          const wasDragged = movedDist > 0.6;
          draggedObject.userData.wasDragged = wasDragged;

          // if it was dragged away, start an autoglide to bring it back smoothly
          if (wasDragged) {
            const now = Date.now();
            draggedObject.userData.autoglide = true;
            draggedObject.userData.autoglideStart = now;
            // duration scales with distance but clamped
            draggedObject.userData.autoglideDuration = Math.min(1400, 400 + Math.round(movedDist * 250));
            draggedObject.userData.autoglideFrom = draggedObject.position.clone();
            draggedObject.userData.autoglideTo = orig.clone();
          }
        }
        draggedObject.userData.isDragging = false;
        draggedObject = null;
        dragConnections = [];
      }
      isDragging = false;
      document.body.style.cursor = 'default';
    });
    
    window.addEventListener('wheel', (event) => {
      if (currentMode === 'void') {
        event.preventDefault();
        cameraDistance += event.deltaY * 0.01;
        cameraDistance = Math.max(MIN_DISTANCE, Math.min(MAX_DISTANCE, cameraDistance));
        updateCameraPosition();
      }
    }, { passive: false });
    
    window.addEventListener('mousemove', (event) => {
      mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
      mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
      
      if (currentMode === 'void') {
        if (!introComplete) return; // block hover/drag interactions until intro completes
        // Handle object dragging
        if (draggedObject) {
          raycaster.setFromCamera(mouse, camera);
          const intersection = new THREE.Vector3();
          raycaster.ray.intersectPlane(dragPlane, intersection);
          draggedObject.position.copy(intersection.add(dragOffset));
          
          // Track last drag position to compute motion if needed (no auto-rotation to avoid jitter)
          draggedObject.userData.lastDragPosition = draggedObject.position.clone();
        } else if (isDragging) {
          const deltaX = event.clientX - previousMousePosition.x;
          const deltaY = event.clientY - previousMousePosition.y;
          
          cameraRotation.theta -= deltaX * 0.005;
          cameraRotation.phi += deltaY * 0.005;
          
          // Clamp phi to prevent going through floor
          cameraRotation.phi = Math.max(MIN_PHI, Math.min(MAX_PHI, cameraRotation.phi));
          
          updateCameraPosition();
          
          previousMousePosition = { x: event.clientX, y: event.clientY };
        }
        
        // Move key light with cursor
        keyLight.position.x = 8 + mouse.x * 5;
        keyLight.position.z = 8 + mouse.y * 5;
        
        if (!draggedObject && !isDragging) {
          raycaster.setFromCamera(mouse, camera);
          
          // Check for shard intersections
          const shardIntersects = raycaster.intersectObjects(shardMeshes);
          
          if (hoveredShard && (!shardIntersects.length || shardIntersects[0].object !== hoveredShard)) {
            hoveredShard.userData.hovered = false;
            hoveredShard.material.emissive.setHex(0x000000);
            hoveredShard.material.emissiveIntensity = 0;
            hoveredShard = null;
            label.classList.remove('visible');
          }
          
          if (shardIntersects.length > 0) {
            const shard = shardIntersects[0].object;
            if (shard !== hoveredShard) {
              hoveredShard = shard;
              shard.userData.hovered = true;
              const project = projects[shard.userData.projectId];
              shard.material.emissive.setHex(project.color);
              shard.material.emissiveIntensity = 0.8;
              
              labelName.textContent = project.name;
              labelDesc.textContent = project.desc;
              
              const vector = new THREE.Vector3();
              shard.getWorldPosition(vector);
              vector.project(camera);
              
              const x = (vector.x * 0.5 + 0.5) * window.innerWidth;
              const y = (-(vector.y * 0.5) + 0.5) * window.innerHeight;
              
              label.style.left = x + 'px';
              label.style.top = (y - 80) + 'px';
              label.classList.add('visible');
            }
          }
          
          // Check for debris intersections
          const debrisIntersects = raycaster.intersectObjects(debrisShards);
          
          if (hoveredDebris && (!debrisIntersects.length || debrisIntersects[0].object !== hoveredDebris)) {
            hoveredDebris = null;
            // Mark lines for fade out instead of clearing immediately
            connectionLines.forEach(lineData => {
              if (!lineData.fadingOut) {
                lineData.fadingOut = true;
                lineData.fadeStartTime = Date.now();
              }
            });
            lineAnimations.forEach(lineData => {
              if (!lineData.fadingOut) {
                lineData.fadingOut = true;
                lineData.fadeStartTime = Date.now();
              }
            });
          }
          
          if (debrisIntersects.length > 0) {
            const debris = debrisIntersects[0].object;
            if (debris !== hoveredDebris) {
              hoveredDebris = debris;
              createConnectionLines();
            }
          }
        }
      }
    });
    
    window.addEventListener('click', () => {
      if (!introComplete) return; // block clicks until intro completes
      if (currentMode === 'void' && hoveredDebris && !isDragging) {
        // If user clicks debris, create the connection chain
        createConnectionLines();
      } else if (currentMode === 'void' && hoveredShard && !isDragging) {
        label.classList.remove('visible');
        const projectId = hoveredShard.userData.projectId;
        enterProjectWorld(projectId);
      }
    });
    
    document.getElementById('back-button').addEventListener('click', () => {
      exitProjectWorld();
    });
    
    // Animation loop
    let time = 0;
    
    function animate() {
      requestAnimationFrame(animate);
      time += 0.016;
      
      if (currentMode === 'void') {
        // If intro shatter is running, animate shards with simple physics (velocity, gravity, damping)
        let allShardsDone = true;
        const nowGlobal = Date.now();
        const dt = 0.016; // fixed step for stability
        shardMeshes.forEach(shard => {
          const data = shard.userData;

          if (data.shattering) {
            const startT = data.shatterStart || 0;
            if (nowGlobal < startT) {
              allShardsDone = false;
              return; // not started yet
            }

            // initialize velocity once at start
            if (!data._velInitialized) {
              const target = data.targetPosition || new THREE.Vector3(Math.cos(data.orbitAngle) * data.orbitRadius, data.originalY, Math.sin(data.orbitAngle) * data.orbitRadius);
              // base outward direction toward target in XZ plus an upward bias
              const baseDir = new THREE.Vector3(target.x, target.y, target.z).normalize();
              const rand = new THREE.Vector3((Math.random() - 0.5), (Math.random() * 0.8 + 0.2), (Math.random() - 0.5)).normalize();
              const velVec = baseDir.clone().add(rand.multiplyScalar(0.8)).normalize().multiplyScalar(EXPLOSION_FORCE * (0.9 + Math.random() * 0.6));
              data.velocity = velVec;
              data._velInitialized = true;
              data._shatterInitTime = nowGlobal;
              // set a target final scale for smooth growth
              data._finalScale = 1;
            }

            // integrate physics
            data.velocity.y -= GRAVITY * dt;
            data.velocity.multiplyScalar(DAMPING);
            shard.position.x += data.velocity.x * dt;
            shard.position.y += data.velocity.y * dt;
            shard.position.z += data.velocity.z * dt;

            // scale up over time
            const elapsed = nowGlobal - (data._shatterInitTime || nowGlobal);
            const prog = Math.min(1, elapsed / (data.shatterDuration || 800));
            const s = THREE.MathUtils.lerp(0.001, data._finalScale, prog);
            shard.scale.setScalar(s);

            shard.rotation.x += 0.02 + 0.03 * Math.random();
            shard.rotation.y += 0.01 + 0.02 * Math.random();

            // finish condition: if enough time passed and velocity slowed, snap to target
            const target = data.targetPosition;
            if ((elapsed > (data.shatterDuration || 800) && (data.velocity.length() < 0.8)) || (nowGlobal - startT) > ((data.shatterDuration || 800) + 1200)) {
              if (target) shard.position.copy(target);
              shard.scale.setScalar(data._finalScale);
              data.velocity.set(0, 0, 0);
              data.shattering = false;
            } else {
              allShardsDone = false;
            }
          } else if (!introComplete) {
            // keep at origin until intro completes
            shard.position.set(0, 0, 0);
            shard.scale.setScalar(0.001);
            allShardsDone = false;
          } else {
            // normal idle orbit behavior after intro
            if (!data.isDragging) {
              data.orbitAngle += data.orbitSpeed;
              shard.position.x = Math.cos(data.orbitAngle) * data.orbitRadius;
              shard.position.z = Math.sin(data.orbitAngle) * data.orbitRadius;
              shard.position.y = data.targetPosition ? data.targetPosition.y + Math.sin(time * data.floatSpeed + data.floatOffset) * 1 : data.originalY + Math.sin(time * data.floatSpeed + data.floatOffset) * 1;
            } else if (data.originalPosition) {
              const pullStrength = 0.01; // Slower snap back
              shard.position.lerp(data.originalPosition, pullStrength);
            }

            shard.rotation.x += data.rotationSpeedX;
            shard.rotation.y += data.rotationSpeedY;
            shard.rotation.z += data.rotationSpeedZ;

            const targetScale = data.hovered ? 1.25 : 1;
            shard.scale.x += (targetScale - shard.scale.x) * 0.08;
            shard.scale.y += (targetScale - shard.scale.y) * 0.08;
            shard.scale.z += (targetScale - shard.scale.z) * 0.08;
          }
        });
        
        // Animate debris shards (including intro shatter) with physics
        let allDebrisDone = true;
        const nowGlobal2 = Date.now();
        debrisShards.forEach(debris => {
          const data = debris.userData;

          if (data.shattering) {
            const startT = data.shatterStart || 0;
            if (nowGlobal2 < startT) {
              allDebrisDone = false;
              return;
            }

            // initialize velocity if needed
            if (!data._velInitialized) {
              const target = data.targetPosition || new THREE.Vector3(Math.cos(data.orbitAngle) * data.orbitRadius, data.originalY, Math.sin(data.orbitAngle) * data.orbitRadius);
              const baseDir = target.clone().normalize();
              const rand = new THREE.Vector3((Math.random() - 0.5), (Math.random() * 0.8 + 0.2), (Math.random() - 0.5)).normalize();
              const velVec = baseDir.clone().add(rand.multiplyScalar(0.9)).normalize().multiplyScalar(EXPLOSION_FORCE * (1.0 + Math.random() * 0.8));
              data.velocity = velVec;
              data._velInitialized = true;
              data._shatterInitTime = nowGlobal2;
              data._finalScale = data._finalScale || (0.25 + Math.random() * 0.35);
            }

            // integrate
            const dt = 0.016;
            data.velocity.y -= GRAVITY * dt * 0.9;
            data.velocity.multiplyScalar(DAMPING);
            debris.position.x += data.velocity.x * dt;
            debris.position.y += data.velocity.y * dt;
            debris.position.z += data.velocity.z * dt;

            const elapsed = nowGlobal2 - (data._shatterInitTime || nowGlobal2);
            const prog = Math.min(1, elapsed / (data.shatterDuration || 600));
            const s = THREE.MathUtils.lerp(0.001, data._finalScale, prog);
            debris.scale.setScalar(s);

            debris.rotation.x += 0.03 + 0.02 * Math.random();
            debris.rotation.y += 0.02 + 0.03 * Math.random();

            if ((elapsed > (data.shatterDuration || 600) && data.velocity.length() < 0.8) || (nowGlobal2 - startT) > ((data.shatterDuration || 600) + 1000)) {
              if (data.targetPosition) debris.position.copy(data.targetPosition);
              debris.scale.setScalar(data._finalScale || 0.25);
              data.velocity.set(0, 0, 0);
              data.shattering = false;
            } else {
              allDebrisDone = false;
            }
          } else if (!introComplete) {
            debris.position.set(0, 0, 0);
            debris.scale.setScalar(0.001);
            allDebrisDone = false;
          } else {
            if (!data.isDragging) {
              data.orbitAngle += data.orbitSpeed;
              debris.position.x = Math.cos(data.orbitAngle) * data.orbitRadius;
              debris.position.z = Math.sin(data.orbitAngle) * data.orbitRadius;
              debris.position.y = data.targetPosition ? data.targetPosition.y + Math.sin(time * data.floatSpeed + data.floatOffset) * 0.8 : data.originalY + Math.sin(time * data.floatSpeed + data.floatOffset) * 0.8;
            } else if (data.originalPosition) {
              const pullStrength = 0.008;
              debris.position.lerp(data.originalPosition, pullStrength);
            }

            debris.rotation.x += data.rotationSpeedX;
            debris.rotation.y += data.rotationSpeedY;
            debris.rotation.z += data.rotationSpeedZ;
          }
        });

        // Update intro particle burst if present
        if (introParticles) {
          const p = introParticles;
          const geom = p.mesh.geometry;
          const pos = geom.attributes.position.array;
          const vel = p.velocities;
          const elapsed = Date.now() - p.startTime;
          const life = p.life;
          const dt = 0.016;
          for (let i = 0; i < PARTICLE_COUNT; i++) {
            // apply gravity and damping
            vel[i * 3 + 1] -= GRAVITY * dt * 0.6;
            vel[i * 3] *= DAMPING;
            vel[i * 3 + 1] *= DAMPING;
            vel[i * 3 + 2] *= DAMPING;

            pos[i * 3] += vel[i * 3] * dt;
            pos[i * 3 + 1] += vel[i * 3 + 1] * dt;
            pos[i * 3 + 2] += vel[i * 3 + 2] * dt;
          }
          geom.attributes.position.needsUpdate = true;
          // fade material
          const fade = Math.max(0, 1 - elapsed / life);
          p.mesh.material.opacity = fade * 0.9;
          if (elapsed > life) {
            scene.remove(p.mesh);
            if (p.mesh.geometry) p.mesh.geometry.dispose();
            if (p.mesh.material) p.mesh.material.dispose();
            introParticles = null;
          }
        }

        // --- Dynamic environment interactions: fog pulse & ripple ---
        // Compute a weighted focus point and color from the nearest shards
        // to the camera's forward point. This lets multiple shards subtly
        // influence the fog (creates cyan/violet pulses when you look around).
        let focusPoint = null;
        const focusColor = new THREE.Color(0x66ccff);

        // how many nearest shards to sample
        const NEAREST_COUNT = 3;

        // If user explicitly hovers a shard, bias toward it but still include neighbors
        if (hoveredShard) {
          // base focus on hovered shard but force the fog tint to the cinematic deep blue
          focusPoint = hoveredShard.position.clone();
          focusColor.setHex(KEY_COLOR);
        } else if (shardMeshes.length > 0) {
          // cast a short ray forward from camera to get an approximate focal point
          const camDir = new THREE.Vector3();
          camera.getWorldDirection(camDir);
          const camPoint = camera.position.clone().add(camDir.multiplyScalar(10));

          // gather distances to camPoint
          const arr = shardMeshes.map(s => ({ mesh: s, d: s.position.distanceTo(camPoint) }));
          arr.sort((a, b) => a.d - b.d);

          // take up to NEAREST_COUNT shards and compute weighted average by inverse distance
          let totalW = 0;
          const avgPos = new THREE.Vector3(0, 0, 0);
          const accumColor = new THREE.Color(0x000000);
          const count = Math.min(NEAREST_COUNT, arr.length);
          for (let i = 0; i < count; i++) {
            const item = arr[i];
            const d = Math.max(0.001, item.d);
            const w = 1.0 / d; // closer shards get more weight
            totalW += w;
            avgPos.addScaledVector(item.mesh.position, w);
            // Ignore individual project colors for fog — always use cinematic deep blue
            const c = new THREE.Color(KEY_COLOR);
            accumColor.r += c.r * w;
            accumColor.g += c.g * w;
            accumColor.b += c.b * w;
          }

          if (totalW > 0) {
            avgPos.multiplyScalar(1 / totalW);
            accumColor.r /= totalW;
            accumColor.g /= totalW;
            accumColor.b /= totalW;
            focusPoint = avgPos;
            focusColor.copy(accumColor);
          }
        }

        if (focusPoint) {
          // compute a representative distance (use distance to camera)
          const camDist = camera.position.distanceTo(focusPoint);
          const influence = Math.max(0, 1 - Math.min(camDist / MAX_FOG_PULSE_DISTANCE, 1));

          // update soft point light (fogPulseLight) for physical shading fallback
          fogPulseLight.position.copy(focusPoint);
          // keep pulse subtle: lower multiplier, softer falloff
          fogPulseLight.intensity = 0.9 * Math.pow(influence, 1.2);
          // Force the fog/light tint to the cinematic KEY_COLOR so the haze
          // remains consistently deep-blue and never becomes yellow/green.
          focusColor.setHex(KEY_COLOR);
          fogPulseLight.color.lerp(focusColor, 0.9);

          // subtly tint the scene fog toward the focus color (mostly BASE_FOG_COLOR)
          const targetFog = focusColor.clone().multiplyScalar(0.42).add(BASE_FOG_COLOR.clone().multiplyScalar(0.58));
          const lerpAmt = 0.06 * influence; // per-frame lerp amount
          scene.fog.color.lerp(targetFog, lerpAmt);

          // push values into a postprocessing fog pass if present so the shader
          // gets the same focus information (keeps both paths consistent)
          try {
            if (typeof fogPass !== 'undefined' && fogPass && fogPass.uniforms) {
              if (fogPass.uniforms['lightPos'] && fogPass.uniforms['lightPos'].value) fogPass.uniforms['lightPos'].value.copy(focusPoint);
              if (fogPass.uniforms['lightColor'] && fogPass.uniforms['lightColor'].value) fogPass.uniforms['lightColor'].value.copy(focusColor);
              if (fogPass.uniforms['baseDensity']) fogPass.uniforms['baseDensity'].value = 0.012 + 0.02 * influence;
            }
          } catch (e) {
            // ignore if fogPass not available or uniforms missing
          }

          // tweak ripple plane color/opacity to match
          if (rippleUniforms) {
            // keep ripple color locked to KEY_COLOR (deep-blue) to avoid hue shifts
            if (rippleUniforms.uColor && rippleUniforms.uColor.value) rippleUniforms.uColor.value.setHex(KEY_COLOR);
            if (rippleUniforms.uOpacity) rippleUniforms.uOpacity.value = 0.06 + 0.18 * influence;
          }
        } else {
          // fade back to base fog color
          scene.fog.color.lerp(BASE_FOG_COLOR, 0.01);
          fogPulseLight.intensity = Math.max(0, fogPulseLight.intensity - 0.01);
          if (rippleUniforms) {
            rippleUniforms.uColor.value.lerp(new THREE.Color(0x000000), 0.02);
            rippleUniforms.uOpacity.value = THREE.MathUtils.lerp(rippleUniforms.uOpacity.value, 0.12, 0.02);
          }
        }

        // drive ripple time uniform
        if (rippleUniforms) rippleUniforms.uTime.value = performance.now() * 0.001;


        // If all shards and debris finished shattering, mark introComplete so normal behavior begins
        if (!introComplete) {
          const anyShattering = shardMeshes.some(s => s.userData.shattering);
          const anyDebrisShattering = debrisShards.some(d => d.userData.shattering);
          if (!anyShattering && !anyDebrisShattering) {
            introComplete = true;
            // ensure final positions and scales are set
            shardMeshes.forEach(s => { if (s.userData.targetPosition) s.position.copy(s.userData.targetPosition); s.scale.setScalar(1); });
            debrisShards.forEach(d => { if (d.userData.targetPosition) d.position.copy(d.userData.targetPosition); d.scale.setScalar(d.userData._finalScale || 0.25); });
          }
        }
        
        // Draw lines from drag connections to dragged object
  if (draggedObject && dragConnections.length > 0 && draggedObject.userData && draggedObject.userData.wasDragged) {
          dragConnections.forEach((connector, index) => {
            // Create visual lines showing the pull connections as a black outline + white center
            const lineKey = `drag-line-${index}`;
            let dragGroup = scene.getObjectByName(lineKey);

            // Build or update a Group that contains two lines: outline (black) and center (white)
            if (!dragGroup) {
              const startPos = connector.position.clone();
              const endPos = draggedObject.position.clone();

              const outlineMatMesh = new THREE.MeshBasicMaterial({ color: 0xffffff, transparent: true, opacity: 0.95 });
              const outlineGroup = createConnectorCylinder(startPos, endPos, 0.04, outlineMatMesh); // thinner and white

              // add the anchored outline group directly and name it so we can find/update it
              outlineGroup.name = lineKey;
              scene.add(outlineGroup);
              dragGroup = outlineGroup;
            } else {
              // Update anchored outline group (we store the anchored parent as dragGroup)
              // dragGroup is the parent returned by createConnectorCylinder; child mesh is at children[0]
              const start = connector.position.clone();
              const end = draggedObject.position.clone();
              const dir = new THREE.Vector3().subVectors(end, start);
              const fullLen = Math.max(dir.length(), 0.001);

              // update parent position & orientation
              if (dragGroup) {
                dragGroup.position.copy(start);
                dragGroup.quaternion.setFromUnitVectors(new THREE.Vector3(0, 1, 0), dir.clone().normalize());

                // compute growth progress
                const now = Date.now();
                const growStart = (dragGroup.userData && dragGroup.userData.growStartTime) || now;
                const growDur = (dragGroup.userData && dragGroup.userData.growDuration) || 400;
                const t = Math.min(1, Math.max(0, (now - growStart) / growDur));

                const childMesh = dragGroup.children && dragGroup.children[0];
                if (childMesh) {
                  childMesh.scale.x = 1;
                  childMesh.scale.z = 1;
                  childMesh.scale.y = Math.max(0.001, fullLen * t);
                }
              }
            }
            
            // Apply pull force only when this piece is being pulled back (was previously dragged out)
            if (draggedObject.userData && draggedObject.userData.wasDragged) {
              const direction = new THREE.Vector3().subVectors(
                draggedObject.userData.originalPosition,
                draggedObject.position
              );
              const distance = direction.length();

              // Apply stronger pull the further it is
              if (distance > 0.1) {
                const pullForce = direction.normalize().multiplyScalar(distance * 0.03);
                draggedObject.position.add(pullForce);
              }
            }
          });
        } else {
          // Clean up drag lines when not dragging
          for (let i = 0; i < 5; i++) {
            const lineKey = `drag-line-${i}`;
            const dragGroup = scene.getObjectByName(lineKey);
            if (dragGroup) {
              // recursively dispose children and nested children
              const disposeRec = (obj) => {
                if (!obj) return;
                if (obj.geometry) { try { obj.geometry.dispose(); } catch(e) {} }
                if (obj.material) {
                  if (Array.isArray(obj.material)) obj.material.forEach(m => { try { m.dispose(); } catch(e) {} });
                  else try { obj.material.dispose(); } catch(e) {}
                }
                if (obj.children && obj.children.length) {
                  obj.children.forEach(c => disposeRec(c));
                }
              };

              disposeRec(dragGroup);
              scene.remove(dragGroup);
            }
          }
        }
        
        // Animate mist particles
        const positions = particles.geometry.attributes.position.array;
        for (let i = 1; i < positions.length; i += 3) {
          positions[i] += Math.sin(time * 0.1 + i) * 0.005;
        }
        particles.geometry.attributes.position.needsUpdate = true;
        particles.rotation.y += 0.0001;
        
        // Animate connection lines
        for (let i = lineAnimations.length - 1; i >= 0; i--) {
          const lineData = lineAnimations[i];
          const currentTime = Date.now();
          
          if (lineData.fadingOut) {
            // Fade out over 2 seconds
            const fadeProgress = (currentTime - lineData.fadeStartTime) / 2000;
            lineData.outlineMaterial.opacity = Math.max(0, 0.9 * (1 - fadeProgress));
            lineData.centerMaterial.opacity = Math.max(0, 0.9 * (1 - fadeProgress));
            
            if (fadeProgress >= 1) {
              scene.remove(lineData.outlineLine);
              scene.remove(lineData.centerLine);
              lineData.outlineGeometry.dispose();
              lineData.centerGeometry.dispose();
              lineData.outlineMaterial.dispose();
              lineData.centerMaterial.dispose();
              
              lineAnimations.splice(i, 1);
              const index = connectionLines.indexOf(lineData);
              if (index > -1) connectionLines.splice(index, 1);
            }
          } else {
            // Animate line growth - faster and smoother
            const elapsed = (currentTime - lineData.startTime) / 1000;
            const adjustedTime = Math.max(0, elapsed - lineData.delay);
            lineData.progress = Math.min(1, adjustedTime / 0.5); // 0.5 second growth per segment (faster)
            
            if (lineData.progress > 0) {
              // Get live positions
              const startPos = lineData.startDebris.position;
              const endPos = lineData.isFinalSegment ? lineData.endShard.position : lineData.endDebris.position;
              
              const currentEnd = new THREE.Vector3().lerpVectors(
                startPos,
                endPos,
                lineData.progress
              );
              
              // Update outline with live tracking
              const outlinePositions = lineData.outlineGeometry.attributes.position.array;
              outlinePositions[0] = startPos.x;
              outlinePositions[1] = startPos.y;
              outlinePositions[2] = startPos.z;
              outlinePositions[3] = currentEnd.x;
              outlinePositions[4] = currentEnd.y;
              outlinePositions[5] = currentEnd.z;
              lineData.outlineGeometry.attributes.position.needsUpdate = true;
              
              // Update center line with live tracking
              const centerPositions = lineData.centerGeometry.attributes.position.array;
              centerPositions[0] = startPos.x;
              centerPositions[1] = startPos.y;
              centerPositions[2] = startPos.z;
              centerPositions[3] = currentEnd.x;
              centerPositions[4] = currentEnd.y;
              centerPositions[5] = currentEnd.z;
              lineData.centerGeometry.attributes.position.needsUpdate = true;
            }
          }
        }
        
        // Animate glow effects, dots and dot-lines (handle fading/removal)
        for (let i = connectionLines.length - 1; i >= 0; i--) {
          const lineData = connectionLines[i];

          // Glow handling (existing behavior)
          if (lineData.isGlow) {
            if (lineData.fadingOut) {
                const fadeProgress = (Date.now() - lineData.fadeStartTime) / 2000;
                lineData.material.opacity = Math.max(0, 0.5 * (1 - fadeProgress));

                if (fadeProgress >= 1) {
                  // remove mesh and dispose materials/geometry (handle grouped mesh)
                  if (lineData.mesh) {
                    if (lineData.mesh.children && lineData.mesh.children.length) {
                      lineData.mesh.children.forEach(child => {
                        if (child.geometry) child.geometry.dispose();
                        if (child.material) {
                          if (Array.isArray(child.material)) child.material.forEach(m => m.dispose());
                          else child.material.dispose();
                        }
                      });
                    }
                    scene.remove(lineData.mesh);
                  }

                  if (lineData.material && !(lineData.mesh && lineData.mesh.material)) {
                    // dispose standalone material if present (glow material)
                    if (Array.isArray(lineData.material)) lineData.material.forEach(m => m.dispose());
                    else lineData.material.dispose();
                  }

                  const idx = connectionLines.indexOf(lineData);
                  if (idx > -1) connectionLines.splice(idx, 1);
                }
              } else {
                // Pulse the glow (white outline mesh)
                const pulse = Math.sin(time * 3) * 0.5 + 0.5;
                lineData.material.opacity = 0.3 + pulse * 0.2;
                if (lineData.mesh) lineData.mesh.scale.setScalar(1.5 + pulse * 0.15);

                // Sync position and rotation with target shard (no glitching)
                if (lineData.targetShard) {
                  lineData.mesh.position.copy(lineData.targetShard.position);
                  lineData.mesh.rotation.copy(lineData.targetShard.rotation);
                }
              }
          }

          // Dots and dot-lines fade-out handling
          if (lineData.isDot || lineData.isDotLine) {
            if (lineData.fadingOut) {
              const fadeProgress = (Date.now() - lineData.fadeStartTime) / 1000; // faster fade for dots
              if (lineData.material) lineData.material.opacity = Math.max(0, (lineData.material.opacity || 1) * (1 - fadeProgress));

              if (fadeProgress >= 1) {
                // remove mesh/line and dispose current geometries/materials
                if (lineData.mesh) {
                  scene.remove(lineData.mesh);
                  if (lineData.mesh.geometry) lineData.mesh.geometry.dispose();
                  if (lineData.mesh.material) {
                    if (Array.isArray(lineData.mesh.material)) lineData.mesh.material.forEach(m => m.dispose());
                    else lineData.mesh.material.dispose();
                  }
                }
                if (lineData.line) {
                  scene.remove(lineData.line);
                  if (lineData.line.geometry) lineData.line.geometry.dispose();
                  if (lineData.line.material) {
                    if (Array.isArray(lineData.line.material)) lineData.line.material.forEach(m => m.dispose());
                    else lineData.line.material.dispose();
                  }
                }

                connectionLines.splice(i, 1);
              }
            } else {
              // Keep dots/lines synced to their waypoints so they follow animated objects
              if (lineData.isDot && lineData.mesh && lineData.waypoint) {
                lineData.mesh.position.copy(lineData.waypoint.position);
              }
              if (lineData.isDotLine && lineData.line && lineData.startWaypoint && lineData.endWaypoint) {
                const pts = [lineData.startWaypoint.position.clone(), lineData.endWaypoint.position.clone()];
                lineData.geometry.setFromPoints(pts);
                if (lineData.geometry.attributes && lineData.geometry.attributes.position) lineData.geometry.attributes.position.needsUpdate = true;
              }
              // If the outline for the dot-line is a mesh (cylinder), update its geometry/transform as the waypoints move
              if (lineData.isDotLine && lineData.mesh && lineData.startWaypoint && lineData.endWaypoint) {
                // outline is returned as a parent Object3D (mesh = parent).children[0] is the cylinder mesh
                const start = lineData.startWaypoint.position.clone();
                const end = lineData.endWaypoint.position.clone();
                const dir = new THREE.Vector3().subVectors(end, start);
                const fullLen = Math.max(dir.length(), 0.001);

                // update parent position & orientation
                lineData.mesh.position.copy(start);
                lineData.mesh.quaternion.setFromUnitVectors(new THREE.Vector3(0, 1, 0), dir.clone().normalize());

                // determine growth progress
                const now = Date.now();
                const growStart = lineData.growStartTime || lineData.startTime || now;
                const growDur = lineData.growDuration || 400;
                const t = Math.min(1, Math.max(0, (now - growStart) / growDur));

                // scale the child mesh in Y to represent current length (unit geometry scaled)
                const child = lineData.mesh.children[0];
                if (child) {
                  child.scale.x = 1;
                  child.scale.z = 1;
                  child.scale.y = Math.max(0.001, fullLen * t);
                }
              }
            }
          }
        }
        
      } else if (currentMode === 'project') {
        // Animate project worlds
        if (currentProjectId === 0) { // Neural AI
          projectObjects.forEach((obj, i) => {
            if (obj.geometry && obj.geometry.type === 'SphereGeometry') {
              const pulse = Math.sin(time * obj.userData.pulseSpeed + obj.userData.pulseOffset);
              obj.scale.setScalar(1 + pulse * 0.2);
              obj.material.opacity = 0.6 + pulse * 0.2;
            }
          });
        } else if (currentProjectId === 1) { // Web Dashboard
          projectObjects.forEach(panel => {
            if (panel.userData.angle !== undefined) {
              panel.userData.angle += panel.userData.rotationSpeed;
              panel.position.x = Math.cos(panel.userData.angle) * 6;
              panel.position.z = Math.sin(panel.userData.angle) * 6;
              panel.lookAt(0, 0, 0);
            }
          });
        } else if (currentProjectId === 2) { // Game Engine
          projectObjects.forEach(voxel => {
            voxel.rotation.y = time * 0.2;
          });
        } else if (currentProjectId === 3) { // Data Viz
          projectObjects.forEach(bar => {
            if (bar.userData.originalHeight) {
              const pulse = Math.sin(time * bar.userData.pulseSpeed + bar.userData.pulseOffset);
              const newHeight = bar.userData.originalHeight * (0.7 + pulse * 0.3);
              bar.scale.y = newHeight / bar.userData.originalHeight;
              bar.position.y = newHeight / 2 - 3;
              bar.material.emissiveIntensity = 0.3 + pulse * 0.3;
            }
          });
        } else if (currentProjectId === 4) { // Blockchain
          projectObjects.forEach(block => {
            if (block.userData.rotationSpeed) {
              block.rotation.x += block.userData.rotationSpeed;
              block.rotation.y += block.userData.rotationSpeed * 0.7;
              block.userData.angle += 0.001;
              block.position.x = Math.cos(block.userData.angle) * block.userData.radius;
              block.position.z = Math.sin(block.userData.angle) * block.userData.radius;
            }
          });
        }
        
        camera.lookAt(0, 0, 0);
      }
      
      renderer.render(scene, camera);
    }
    
    animate();
    
    window.addEventListener('resize', () => {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    });
  </script>
</body>
</html>